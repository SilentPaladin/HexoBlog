---
title: Python黑马笔记
tags:
  - 编程语言
  - Python
swiper: false
top: false
toc: true
tocOpen: true
onlyTitle: false
comments: true
share: true
copyright: true
donate: false
mathjax: true
imgTop: true
img: https://cdn.pixabay.com/photo/2024/01/17/17/14/bird-8515097_1280.jpg
excerpt: python黑马搬运笔记
categories: 计算机
date: 2024-10-08 17:05:16
---


# 一、注释

## 目标

- 注释的作用
- 单行注释（行注释）
- 多行注释（块注释）

## 1. 注释的作用

> 使用用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性
> 

## 2. 单行注释(行注释)

- 以 `#` 开头，`#` 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用
- 示例代码如下：

```python
# 这是第一个单行注释
print("hello python")

```

> 为了保证代码的可读性，# 后面建议先添加一个空格，然后再编写相应的说明文字
> 

### 在代码后面增加的单行注释

- 在程序开发时，同样可以使用 `#` 在代码的后面（旁边）增加说明性的文字
- 但是，需要注意的是，**为了保证代码的可读性**，**注释和代码之间** 至少要有 **两个空格**
- 示例代码如下：

```python
print("hello python")  # 输出 `hello python`

```

## 3. 多行注释（块注释）

- 如果希望编写的 **注释信息很多，一行无法显示**，就可以使用多行注释
- 要在 Python 程序中使用多行注释，可以用 **一对 连续的 三个 引号**(单引号和双引号都可以)
- 示例代码如下：

```python
"""
这是一个多行注释

在多行注释之间，可以写很多很多的内容……
"""
print("hello python")

```

### 什么时候需要使用注释？

1. **注释不是越多越好**，对于一目了然的代码，不需要添加注释
2. 对于 **复杂的操作**，应该在操作开始前写上若干行注释
3. 对于 **不是一目了然的代码**，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格）
4. 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么

> 在一些正规的开发团队，通常会有 代码审核 的惯例，就是一个团队中彼此阅读对方的代码
> 

### 关于代码规范

- `Python` 官方提供有一系列 PEP（Python Enhancement Proposals） 文档
- 其中第 8 篇文档专门针对 **Python 的代码格式** 给出了建议，也就是俗称的 **PEP 8**
- 文档地址：[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
- 谷歌有对应的中文文档：[http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/](http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/)

> 任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步
> 

# 二、算数运算符

**计算机**，顾名思义就是负责进行 **数学计算** 并且 **存储计算结果** 的电子设备

## 目标

- 算术运算符的基本使用

## 1. 算数运算符

- 算数运算符是 **运算符的一种**
- 是完成基本的算术运算使用的符号，用来处理四则运算
    | 运算符 | 描述   | 实例                                       |
    | ------ | ------ | ------------------------------------------ |
    | +      | 加     | 10 + 20 = 30                               |
    | -      | 减     | 10 - 20 = -10                              |
    | *      | 乘     | 10 * 20 = 200                              |
    | /      | 除     | 10 / 20 = 0.5                              |
    | //     | 取整除 | 返回除法的整数部分（商） 9 // 2 输出结果 4 |
    | %      | 取余数 | 返回除法的余数 9 % 2 = 1                   |
    | **     | 幂     | 又称次方、乘方，2 ** 3 = 8                 |
- 在 Python 中 `` 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果
    ```python
    In [1]: "-" * 50
    Out[1]: '----------------------------------------'
    ```

## 2. 算数运算符的优先级

- 和数学中的运算符的优先级一致，在 Python 中进行数学计算时，同样也是：
- **先乘除后加减**
- 同级运算符是 **从左至右** 计算
- 可以使用 `()` 调整计算的优先级
- 以下表格的算数优先级由高到最低顺序排列
    | 运算符   | 描述                   |
    | -------- | ---------------------- |
    | **       | 幂 (最高优先级)        |
    | * / % // | 乘、除、取余数、取整除 |
    | + -      | 加法、减法             |
- 例如：
  - `2 + 3 * 5 = 17`
  - `(2 + 3) * 5 = 25`
  - `2 * 3 + 5 = 11`
  - `2 * (3 + 5) = 16`

# 三、变量的基本使用

> 程序就是用来处理数据的，而变量就是用来存储数据的

## 目标

- 变量定义
- 变量的类型
- 变量的命名

## 1. 变量定义

- 在 Python 中，每个变量 **在使用前都必须赋值**，变量 **赋值以后** 该变量 **才会被创建**
  - 等号（=）用来给变量赋值
  - `=` 左边是一个变量名
  - `=` 右边是存储在变量中的值
  ```python
  变量名 = 值
  ```

> 变量定义之后，后续就可以直接使用了

### 1) 变量演练1 —— iPython

```python
# 定义 qq_number 的变量用来保存 qq 号码
In [1]: qq_number = "1234567"

# 输出 qq_number 中保存的内容
In [2]: qq_number
Out[2]: '1234567'

# 定义 qq_password 的变量用来保存 qq 密码
In [3]: qq_password = "123"

# 输出 qq_password 中保存的内容
In [4]: qq_password
Out[4]: '123'

```

> 使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用 print 函数
> 

### 2) 变量演练 2 —— PyCharm

```python
# 定义 qq 号码变量
qq_number = "1234567"

# 定义 qq 密码变量
qq_password = "123"

# 在程序中，如果要输出变量的内容，需要使用 print 函数
print(qq_number)
print(qq_password)

```

> 使用解释器执行，如果要输出变量的内容，必须要要使用 print 函数
> 

### 3) 变量演练 3 —— 超市买苹果

> 可以用 其他变量的计算结果 来定义变量变量定义之后，后续就可以直接使用了
> 

**需求**

- 苹果的价格是 **8.5 元/斤**
- 买了 **7.5 斤** 苹果
- 计算付款金额

```python
# 定义苹果价格变量
price = 8.5

# 定义购买重量
weight = 7.5

# 计算金额
money = price * weight

print(money)

```

### 思考题

- 如果 **只要买苹果，就返 5 块钱**
- 请重新计算购买金额

```python
# 定义苹果价格变量
price = 8.5

# 定义购买重量
weight = 7.5

# 计算金额
money = price * weight

# 只要买苹果就返 5 元
money = money - 5
print(money)

```

**提问**

- 上述代码中，一共定义有几个变量？
- 三个：`price`／`weight`／`money`
- `money = money - 5` 是在定义新的变量还是在使用变量？
- 直接使用之前已经定义的变量
- 变量名 只有在 **第一次出现** 才是 **定义变量**
- 变量名 再次出现，不是定义变量，而是直接使用之前定义过的变量
- 在程序开发中，可以修改之前定义变量中保存的值吗？
- 可以
- 变量中存储的值，就是可以 **变** 的

## 2. 变量的类型

- 在内存中创建一个变量，会包括：
1. 变量的名称
2. 变量保存的数据
3. 变量存储数据的类型
4. 变量的地址（标示）

### 2.1 变量类型的演练 —— 个人信息

**需求**

- 定义变量保存小明的个人信息
- 姓名：**小明**
- 年龄：**18** 岁
- 性别：**是**男生
- 身高：**1.75** 米
- 体重：**75.0** 公斤

> 利用 单步调试 确认变量中保存数据的类型
> 

**提问**

1. 在演练中，一共有几种数据类型？
- 4 种
- `str` —— 字符串
- `bool` —— 布尔（真假）
- `int` —— 整数
- `float` —— 浮点数（小数）
2. 在 `Python` 中定义变量时需要指定类型吗？
- 不需要
- `Python` 可以根据 `=` 等号右侧的值，自动推导出变量中存储数据的类型

### 2.2 变量的类型

- 在 `Python` 中定义变量是 **不需要指定类型**（在其他很多高级语言中都需要）
- 数据类型可以分为 **数字型** 和 **非数字型**
- 数字型
- 整型 (`int`)
- 浮点型（`float`）
- 布尔型（`bool`）
- 真 `True` `非 0 数` —— **非零即真**
- 假 `False` `0`
- 复数型 (`complex`)
- 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题
- 非数字型
- 字符串
- 列表
- 元组
- 字典

> 提示：在 Python 2.x 中，整数 根据保存数值的长度还分为：
> 
> - `int`（整数）
> - `long`（长整数）
- 使用 `type` 函数可以查看一个变量的类型

```python
In [1]: type(name)
```

### 2.3 不同类型变量之间的计算

### 1) **数字型变量** 之间可以直接计算

- 在 Python 中，两个数字型变量是可以直接进行 算数运算的
- 如果变量是 `bool` 型，在计算时
- `True` 对应的数字是 `1`
- `False` 对应的数字是 `0`

**演练步骤**

1. 定义整数 `i = 10`
2. 定义浮点数 `f = 10.5`
3. 定义布尔型 `b = True`
- 在 iPython 中，使用上述三个变量相互进行算术运算

### 2) **字符串变量** 之间使用 `+` 拼接字符串

- 在 Python 中，字符串之间可以使用 `+` 拼接生成新的字符串

```python
In [1]: first_name = "三"

In [2]: last_name = "张"

In [3]: first_name + last_name
Out[3]: '三张'

```

### 3) **字符串变量** 可以和 **整数** 使用 `` 重复拼接相同的字符串

```python
In [1]: "-" * 50
Out[1]: '--------------------------------------------------'

```

### 4) **数字型变量** 和 **字符串** 之间 **不能进行其他计算**

```python
In [1]: first_name = "zhang"

In [2]: x = 10

In [3]: x + first_name
---------------------------------------------------------------------------
TypeError: unsupported operand type(s) for +: 'int' and 'str'
类型错误：`+` 不支持的操作类型：`int` 和 `str`

```

### 2.4 变量的输入

- 所谓 **输入**，就是 **用代码** **获取** 用户通过 **键盘** 输入的信息
- 例如：去银行取钱，在 ATM 上输入密码
- 在 Python 中，如果要获取用户在 **键盘** 上的输入信息，需要使用到 `input` 函数

### 1) 关于函数

- 一个 **提前准备好的功能**(别人或者自己写的代码)，**可以直接使用**，而 **不用关心内部的细节**
- 目前已经学习过的函数

| 函数     | 说明              |
| -------- | ----------------- |
| print(x) | 将 x 输出到控制台 |
| type(x)  | 查看 x 的变量类型 |

### 2) input 函数实现键盘输入

- 在 Python 中可以使用 `input` 函数从键盘等待用户的输入
- 用户输入的 **任何内容** Python 都认为是一个 **字符串**
- 语法如下：

```python
字符串变量 = input("提示信息：")
```

### 3) 类型转换函数

| 函数     | 说明                  |
| -------- | --------------------- |
| int(x)   | 将 x 转换为一个整数   |
| float(x) | 将 x 转换到一个浮点数 |

### 4) 变量输入演练 —— 超市买苹果增强版

**需求**

- **收银员输入** 苹果的价格，单位：**元／斤**
- **收银员输入** 用户购买苹果的重量，单位：**斤**
- 计算并且 **输出** 付款金额

### 演练方式 1

```python
# 1. 输入苹果单价
price_str = input("请输入苹果价格：")

# 2. 要求苹果重量
weight_str = input("请输入苹果重量：")

# 3. 计算金额
# 1> 将苹果单价转换成小数
price = float(price_str)

# 2> 将苹果重量转换成小数
weight = float(weight_str)

# 3> 计算付款金额
money = price * weight

print(money)

```

**提问**

1. 演练中，针对 **价格** 定义了几个变量？
- **两个**
- `price_str` 记录用户输入的价格字符串
- `price` 记录转换后的价格数值
2. **思考** —— 如果开发中，需要用户通过控制台 输入 **很多个 数字**，针对每一个数字都要定义两个变量，**方便吗**？

### 演练方式 2 —— 买苹果改进版

3. **定义** 一个 **浮点变量** 接收用户输入的同时，就使用 `float` 函数进行转换

```python
price = float(input("请输入价格:"))

```

- 改进后的好处：
1. 节约空间，只需要为一个变量分配空间
2. 起名字方便，不需要为中间变量起名字
- 改进后的“缺点”：
1. 初学者需要知道，两个函数能够嵌套使用，稍微有一些难度

**提示**

- 如果输入的不是一个数字，程序执行时会出错，有关数据转换的高级话题，后续会讲！

### 2.5 变量的格式化输出

> 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元
> 
- 在 Python 中可以使用 `print` 函数将信息输出到控制台
- 如果希望输出文字信息的同时，**一起输出** **数据**，就需要使用到 **格式化操作符**
- `%` 被称为 **格式化操作符**，专门用于处理字符串中的格式
- 包含 `%` 的字符串，被称为 **格式化字符串**
- `%` 和不同的 **字符** 连用，**不同类型的数据** 需要使用 **不同的格式化字符**

| 格式化字符 | 含义                                                                     |
| ---------- | ------------------------------------------------------------------------ |
| %s         | 字符串                                                                   |
| %d         | 有符号十进制整数，`%06d` 表示输出的整数显示位数，不足的地方使用 `0` 补全 |
| %f         | 浮点数，`%.2f` 表示小数点后只显示两位                                    |
| %%         | 输出 `%`                                                                 |
- 语法格式如下：

```python
print("格式化字符串" % 变量1)
print("格式化字符串" % (变量1, 变量2...))
```

### 格式化输出演练 —— 基本练习

**需求**

1. 定义字符串变量 `name`，输出 **我的名字叫 小明，请多多关照！**
2. 定义整数变量 `student_no`，输出 **我的学号是 000001**
3. 定义小数 `price`、`weight`、`money`，输出 **苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元**
4. 定义一个小数 `scale`，输出 **数据比例是 10.00%**

```python
print("我的名字叫 %s，请多多关照！" % name)
print("我的学号是 %06d" % student_no)
print("苹果单价 %.02f 元／斤，购买 %.02f 斤，需要支付 %.02f 元" % (price, weight, money))
print("数据比例是 %.02f%%" % (scale * 100))

```

### 课后练习 —— 个人名片

**需求**

- 在控制台依次提示用户输入：**姓名**、**公司**、**职位**、**电话**、**邮箱**
- 按照以下格式输出：

```
**************************************************
公司名称

姓名 (职位)

电话：电话
邮箱：邮箱
**************************************************

```

实现代码如下：

```python
"""
在控制台依次提示用户输入：姓名、公司、职位、电话、电子邮箱
"""
name = input("请输入姓名：")
company = input("请输入公司：")
title = input("请输入职位：")
phone = input("请输入电话：")
email = input("请输入邮箱：")

print("*" * 50)
print(company)
print()
print("%s (%s)" % (name, title))
print()
print("电话：%s" % phone)
print("邮箱：%s" % email)
print("*" * 50)

```

# 四、变量的命名

## 目标

- 标识符和关键字
- 变量的命名规则

## 1 标识符和关键字

### 1.1 标识符

> 标示符就是程序员定义的 变量名、函数名
> 
> 
> **名字** 需要有 **见名知义** 的效果，见下图：
> 
- 标示符可以由 **字母**、**下划线** 和 **数字** 组成
- **不能以数字开头**
- **不能与关键字重名**

思考：下面的标示符哪些是正确的，哪些不正确为什么？

```
fromNo12
from#12
my_Boolean
my-Boolean
Obj2
2ndObj
myInt
My_tExt
_test
test!32
haha(da)tt
jack_rose
jack&rose
GUI
G.U.I

```

### 1.2 关键字

- **关键字** 就是在 `Python` 内部已经使用的标识符
- **关键字** 具有特殊的功能和含义
- 开发者 **不允许定义和关键字相同的名字的标示符**

通过以下命令可以查看 `Python` 中的关键字

```python
In [1]: import keyword
In [2]: print(keyword.kwlist)

```

> 提示：关键字的学习及使用，会在后面的课程中不断介绍
> 
> - `import` **关键字** 可以导入一个 **“工具包”**
> - 在 `Python` 中不同的工具包，提供有不同的工具

## 2. 变量的命名规则

> 命名规则 可以被视为一种 惯例，并无绝对与强制
目的是为了 增加代码的识别和可读性
> 

**注意** `Python` 中的 **标识符** 是 **区分大小写的**

1. 在定义变量时，为了保证代码格式，`=` 的左右应该各保留一个空格
2. 在 `Python` 中，如果 **变量名** 需要由 **二个** 或 **多个单词** 组成时，可以按照以下方式命名
1. 每个单词都使用小写字母
2. 单词与单词之间使用 **`_`下划线** 连接
- 例如：`first_name`、`last_name`、`qq_number`、`qq_password`

### 驼峰命名法

- 当 **变量名** 是由二个或多个单词组成时，还可以利用驼峰命名法来命名
- **小驼峰式命名法**
- 第一个单词以小写字母开始，后续单词的首字母大写
- 例如：`firstName`、`lastName`
- **大驼峰式命名法**
- 每一个单词的首字母都采用大写字母
- 例如：`FirstName`、`LastName`、`CamelCase`

# 五、判断（if）语句

## 目标

- 开发中的应用场景
- if 语句体验
- if 语句进阶
- 综合应用

## 1. 开发中的应用场景

生活中的判断几乎是无所不在的，我们每天都在做各种各样的选择，如果这样？如果那样？……

### 程序中的判断

```python
if 今天发工资:

先还信用卡的钱

if 有剩余:

又可以happy了，O(∩_∩)O哈哈~

else:

噢，no。。。还的等30天
else:

盼着发工资

```

### 判断的定义

- 如果 **条件满足**，才能做某件事情，
- 如果 **条件不满足**，就做另外一件事情，或者什么也不做

> 正是因为有了判断，才使得程序世界丰富多彩，充满变化！
> 
> 
> **判断语句** 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支
> 

## 2. if 语句体验

### 2.1 if 判断语句基本语法

在 `Python` 中，**if 语句** 就是用来进行判断的，格式如下：

```python
if 要判断的条件:
条件成立时，要做的事情
……

```

> 注意：代码的缩进为一个 tab 键，或者 4 个空格 —— 建议使用空格
> 
> - 在 Python 开发中，Tab 和空格不要混用！

**我们可以把整个 if 语句看成一个完整的代码块**

### 2.2 判断语句演练 —— 判断年龄

**需求**

1. 定义一个整数变量记录年龄
2. 判断是否满 18 岁 （**>=**）
3. 如果满 18 岁，允许进网吧嗨皮

```python
# 1. 定义年龄变量
age = 18

# 2. 判断是否满 18 岁
# if 语句以及缩进部分的代码是一个完整的代码块
if age >= 18:
print("可以进网吧嗨皮……")

# 3. 思考！- 无论条件是否满足都会执行
print("这句代码什么时候执行?")

```

**注意**：

- `if` 语句以及缩进部分是一个 **完整的代码块**

### 2.3 else 处理条件不满足的情况

**思考**

在使用 `if` 判断时，只能做到满足条件时要做的事情。那如果需要在 **不满足条件的时候**，做某些事情，该如何做呢？

**答案**

`else`，格式如下：

```python
if 要判断的条件:
条件成立时，要做的事情
……
else:
条件不成立时，要做的事情
……

```

**注意**：

- `if` 和 `else` 语句以及各自的缩进部分共同是一个 **完整的代码块**

### 2.4 判断语句演练 —— 判断年龄改进

**需求**

1. 输入用户年龄
2. 判断是否满 18 岁 （**>=**）
3. 如果满 18 岁，允许进网吧嗨皮
4. 如果未满 18 岁，提示回家写作业

```python
# 1. 输入用户年龄
age = int(input("今年多大了？"))

# 2. 判断是否满 18 岁
# if 语句以及缩进部分的代码是一个完整的语法块
if age >= 18:
print("可以进网吧嗨皮……")
else:
print("你还没长大，应该回家写作业！")

# 3. 思考！- 无论条件是否满足都会执行
print("这句代码什么时候执行?")

```

## 3. 逻辑运算

- 在程序开发中，通常 **在判断条件时**，会需要同时判断多个条件
- 只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 **逻辑运算符**
- **逻辑运算符** 可以把 **多个条件** 按照 **逻辑** 进行 **连接**，变成 **更复杂的条件**
- Python 中的 **逻辑运算符** 包括：**与 and**／**或 or**／**非 not** 三种

### 3.1 `and`

```
条件1 and 条件2

```

- **与**／**并且**
- 两个条件同时满足，返回 `True`
- 只要有一个不满足，就返回 `False`

| 条件 1 | 条件 2 | 结果   |
| ------ | ------ | ------ |
| 成立   | 成立   | 成立   |
| 成立   | 不成立 | 不成立 |
| 不成立 | 成立   | 不成立 |
| 不成立 | 不成立 | 不成立 |

### 3.2 `or`

```
条件1 or 条件2

```

- **或**／**或者**
- 两个条件只要有一个满足，返回 `True`
- 两个条件都不满足，返回 `False`

| 条件 1 | 条件 2 | 结果   |
| ------ | ------ | ------ |
| 成立   | 成立   | 成立   |
| 成立   | 不成立 | 成立   |
| 不成立 | 成立   | 成立   |
| 不成立 | 不成立 | 不成立 |

### 3.3 `not`

```
not 条件

```

- **非**／**不是**

| 条件   | 结果   |
| ------ | ------ |
| 成立   | 不成立 |
| 不成立 | 成立   |

### 逻辑运算演练

1. 练习1: 定义一个整数变量 `age`，编写代码判断年龄是否正确
- 要求人的年龄在 0-120 之间
2. 练习2: 定义两个整数变量 `python_score`、`c_score`，编写代码判断成绩
- 要求只要有一门成绩 > 60 分就算合格
3. 练习3: 定义一个布尔型变量 `is_employee`，编写代码判断是否是本公司员工
- 如果不是提示不允许入内

答案 1：

```python
# 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确
age = 100

# 要求人的年龄在 0-120 之间
if age >= 0 and age <= 120:
print("年龄正确")
else:
print("年龄不正确")

```

答案 2：

```python
# 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩
python_score = 50
c_score = 50

# 要求只要有一门成绩 > 60 分就算合格
if python_score > 60 or c_score > 60:
print("考试通过")
else:
print("再接再厉！")

```

答案 3：

```python
# 练习3: 定义一个布尔型变量 `is_employee`，编写代码判断是否是本公司员工
is_employee = True

# 如果不是提示不允许入内
if not is_employee:
print("非公勿内")

```

## 4. if 语句进阶

### 4.1 `elif`

- 在开发中，使用 `if` 可以 **判断条件**
- 使用 `else` 可以处理 **条件不成立** 的情况
- 但是，如果希望 **再增加一些条件**，**条件不同，需要执行的代码也不同** 时，就可以使用 `elif`
- 语法格式如下：

```python
if 条件1:
条件1满足执行的代码
……
elif 条件2:
条件2满足时，执行的代码
……
elif 条件3:
条件3满足时，执行的代码
……
else:
以上条件都不满足时，执行的代码
……

```

- 对比逻辑运算符的代码

```python
if 条件1 and 条件2:
条件1满足 并且 条件2满足 执行的代码
……

```

**注意**

1. `elif` 和 `else` 都必须和 `if` 联合使用，而不能单独使用
2. 可以将 `if`、`elif` 和 `else` 以及各自缩进的代码，看成一个 **完整的代码块**

### elif 演练 —— 女友的节日

**需求**

3. 定义 `holiday_name` 字符串变量记录节日名称
4. 如果是 **情人节** 应该 **买玫瑰**／**看电影**
5. 如果是 **平安夜** 应该 **买苹果**／**吃大餐**
6. 如果是 **生日** 应该 **买蛋糕**
7. 其他的日子每天都是节日啊……

```
holiday_name = "平安夜"

if holiday_name == "情人节":
print("买玫瑰")
print("看电影")
elif holiday_name == "平安夜":
print("买苹果")
print("吃大餐")
elif holiday_name == "生日":
print("买蛋糕")
else:
print("每天都是节日啊……")

```

### 4.2 `if` 的嵌套

> elif 的应用场景是：同时 判断 多个条件，所有的条件是 平级 的
> 
- 在开发中，使用 `if` 进行条件判断，如果希望 **在条件成立的执行语句中** 再 **增加条件判断**，就可以使用 **if 的嵌套**
- **if 的嵌套** 的应用场景就是：**在之前条件满足的前提下，再增加额外的判断**
- **if 的嵌套** 的语法格式，**除了缩进之外** 和之前的没有区别
- 语法格式如下：

```python
if 条件 1:
条件 1 满足执行的代码
……

if 条件 1 基础上的条件 2:
条件 2 满足时，执行的代码
……

# 条件 2 不满足的处理
else:
条件 2 不满足时，执行的代码

# 条件 1 不满足的处理
else:
条件1 不满足时，执行的代码
……

```

### if 的嵌套 演练 —— 火车站安检

**需求**

1. 定义布尔型变量 `has_ticket` 表示是否有车票
2. 定义整型变量 `knife_length` 表示刀的长度，单位：厘米
3. 首先检查是否有车票，如果有，才允许进行 **安检**
4. 安检时，需要检查刀的长度，判断是否超过 20 厘米
- 如果超过 20 厘米，提示刀的长度，不允许上车
- 如果不超过 20 厘米，安检通过
5. 如果没有车票，不允许进门

```python
# 定义布尔型变量 has_ticket 表示是否有车票
has_ticket = True

# 定义整数型变量 knife_length 表示刀的长度，单位：厘米
knife_length = 20

# 首先检查是否有车票，如果有，才允许进行 安检
if has_ticket:
print("有车票，可以开始安检...")

# 安检时，需要检查刀的长度，判断是否超过 20 厘米
# 如果超过 20 厘米，提示刀的长度，不允许上车
if knife_length >= 20:
print("不允许携带 %d 厘米长的刀上车" % knife_length)
# 如果不超过 20 厘米，安检通过
else:
print("安检通过，祝您旅途愉快……")

# 如果没有车票，不允许进门
else:
print("大哥，您要先买票啊")

```

## 5. 综合应用 —— 石头剪刀布

**目标**

6. 强化 **多个条件** 的 **逻辑运算**
7. 体会 `import` 导入模块（“工具包”）的使用

**需求**

8. 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）
9. 电脑 **随机** 出拳 —— 先假定电脑只会出石头，完成整体代码功能
10. 比较胜负

| 序号 | 规则         |
| ---- | ------------ |
| 1    | 石头 胜 剪刀 |
| 2    | 剪刀 胜 布   |
| 3    | 布 胜 石头   |

### 5.1 基础代码实现

- 先 **假定电脑就只会出石头**，完成整体代码功能

```python
# 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）
player = int(input("请出拳 石头（1）／剪刀（2）／布（3）："))

# 电脑 随机 出拳 - 假定电脑永远出石头
computer = 1

# 比较胜负
# 如果条件判断的内容太长，可以在最外侧的条件增加一对大括号
# 再在每一个条件之间，使用回车，PyCharm 可以自动增加 8 个空格
if ((player == 1 and computer == 2) or
(player == 2 and computer == 3) or
(player == 3 and computer == 1)):

print("噢耶！！！电脑弱爆了！！！")
elif player == computer:
print("心有灵犀，再来一盘！")
else:
print("不行，我要和你决战到天亮！")

```

### 5.2 随机数的处理

- 在 `Python` 中，要使用随机数，首先需要导入 **随机数** 的 **模块** —— “工具包”

```python
import random

```

- 导入模块后，可以直接在 **模块名称** 后面敲一个 `.` 然后按 `Tab` 键，会提示该模块中包含的所有函数
- `random.randint(a, b)` ，返回 `[a, b]` 之间的整数，包含 `a` 和 `b`
- 例如：

```python
random.randint(12, 20)  # 生成的随机数n: 12 <= n <= 20
random.randint(20, 20)  # 结果永远是 20
random.randint(20, 10)  # 该语句是错误的，下限必须小于上限

```

# 六、运算符

## 目标

- 算数运算符
- 比较（关系）运算符
- 逻辑运算符
- 赋值运算符
- 运算符的优先级

数学符号表链接：[https://zh.wikipedia.org/wiki/数学符号表](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8)

## 1. 算数运算符

- 是完成基本的算术运算使用的符号，用来处理四则运算

| 运算符 | 描述   | 实例                                       |
| ------ | ------ | ------------------------------------------ |
| +      | 加     | 10 + 20 = 30                               |
| -      | 减     | 10 - 20 = -10                              |
| *      | 乘     | 10 * 20 = 200                              |
| /      | 除     | 10 / 20 = 0.5                              |
| //     | 取整除 | 返回除法的整数部分（商） 9 // 2 输出结果 4 |
| %      | 取余数 | 返回除法的余数 9 % 2 = 1                   |
| **     | 幂     | 又称次方、乘方，2 ** 3 = 8                 |
- 在 Python 中 `` 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果

```python
In [1]: "-" * 50
Out[1]: '----------------------------------------'

```

## 2. 比较（关系）运算符

| 运算符 | 描述                                                                           |
| ------ | ------------------------------------------------------------------------------ |
| ==     | 检查两个操作数的值是否**相等**，如果是，则条件成立，返回 True                  |
| !=     | 检查两个操作数的值是否**不相等**，如果是，则条件成立，返回 True                |
| >      | 检查左操作数的值是否**大于** 右操作数的值，如果是，则条件成立，返回 True       |
| <      | 检查左操作数的值是否**小于** 右操作数的值，如果是，则条件成立，返回 True       |
| >=     | 检查左操作数的值是否**大于或等于** 右操作数的值，如果是，则条件成立，返回 True |
| <=     | 检查左操作数的值是否**小于或等于** 右操作数的值，如果是，则条件成立，返回 True |

> Python 2.x 中判断 不等于 还可以使用 <> 运算符
> 
> 
> `!=` 在 Python 2.x 中同样可以用来判断 **不等于**
> 

## 3. 逻辑运算符

| 运算符 | 逻辑表达式 | 描述                                                                                           |
| ------ | ---------- | ---------------------------------------------------------------------------------------------- |
| and    | x and y    | 只有 x 和 y 的值都为 True，才会返回 True<br />否则只要 x 或者 y 有一个值为 False，就返回 False |
| or     | x or y     | 只要 x 或者 y 有一个值为 True，就返回 True<br />只有 x 和 y 的值都为 False，才会返回 False     |
| not    | not x      | 如果 x 为 True，返回 False<br />如果 x 为 False，返回 True                                     |

## 4. 赋值运算符

- 在 Python 中，使用 `=` 可以给变量赋值
- 在算术运算时，为了简化代码的编写，`Python` 还提供了一系列的 与 **算术运算符** 对应的 **赋值运算符**
- 注意：**赋值运算符中间不能使用空格**

| 运算符 | 描述                      | 实例                                  |
| ------ | ------------------------- | ------------------------------------- |
| =      | 简单的赋值运算符          | c = a + b 将 a + b 的运算结果赋值为 c |
| +=     | 加法赋值运算符            | c += a 等效于 c = c + a               |
| -=     | 减法赋值运算符            | c -= a 等效于 c = c - a               |
| *=     | 乘法赋值运算符            | c *= a 等效于 c = c * a               |
| /=     | 除法赋值运算符            | c /= a 等效于 c = c / a               |
| //=    | 取整除赋值运算符          | c //= a 等效于 c = c // a             |
| %=     | 取**模** (余数)赋值运算符 | c %= a 等效于 c = c % a               |
| **=    | 幂赋值运算符              | c **= a 等效于 c = c ** a             |

## 5. 运算符的优先级

- 以下表格的算数优先级由高到最低顺序排列

| 运算符                   | 描述                   |
| ------------------------ | ---------------------- |
| **                       | 幂 (最高优先级)        |
| * / % //                 | 乘、除、取余数、取整除 |
| + -                      | 加法、减法             |
| <= < > >=                | 比较运算符             |
| == !=                    | 等于运算符             |
| = %= /= //= -= += *= **= | 赋值运算符             |
| not or and               | 逻辑运算符             |

# 七、循环

## 目标

- 程序的三大流程
- while 循环基本使用
- break 和 continue
- while 循环嵌套

## 1. 程序的三大流程

- 在程序开发中，一共有三种流程方式：
- **顺序** —— **从上向下**，顺序执行代码
- **分支** —— 根据条件判断，决定执行代码的 **分支**
- **循环** —— 让 **特定代码 重复** 执行

## 2. `while` 循环基本使用

- 循环的作用就是让 **指定的代码** 重复的执行
- `while` 循环最常用的应用场景就是 **让执行的代码** 按照 **指定的次数** **重复** 执行
- 需求 —— 打印 5 遍 `Hello Python`
- 思考 —— 如果要求打印 100 遍怎么办？

### 2.1 `while` 语句基本语法

```python
初始条件设置 —— 通常是重复执行的 计数器

while 条件(判断 计数器 是否达到 目标次数):
条件满足时，做的事情1
条件满足时，做的事情2
条件满足时，做的事情3
...(省略)...

处理条件(计数器 + 1)

```

**注意**：

- `while` 语句以及缩进部分是一个 **完整的代码块**

### 第一个 while 循环

**需求**

- 打印 5 遍 Hello Python

```
# 1. 定义重复次数计数器
i = 1

# 2. 使用 while 判断条件
while i <= 5:
# 要重复执行的代码
print("Hello Python")

# 处理计数器 i
i = i + 1

print("循环结束后的 i = %d" % i)

```

> 注意：循环结束后，之前定义的计数器条件的数值是依旧存在的
> 

### 死循环

> 由于程序员的原因，忘记 在循环内部 修改循环的判断条件，导致循环持续执行，程序无法终止！
> 

### 2.2 赋值运算符

- 在 Python 中，使用 `=` 可以给变量赋值
- 在算术运算时，为了简化代码的编写，`Python` 还提供了一系列的 与 **算术运算符** 对应的 **赋值运算符**
- 注意：**赋值运算符中间不能使用空格**

| 运算符 | 描述                      | 实例                                  |
| ------ | ------------------------- | ------------------------------------- |
| =      | 简单的赋值运算符          | c = a + b 将 a + b 的运算结果赋值为 c |
| +=     | 加法赋值运算符            | c += a 等效于 c = c + a               |
| -=     | 减法赋值运算符            | c -= a 等效于 c = c - a               |
| *=     | 乘法赋值运算符            | c *= a 等效于 c = c * a               |
| /=     | 除法赋值运算符            | c /= a 等效于 c = c / a               |
| //=    | 取整除赋值运算符          | c //= a 等效于 c = c // a             |
| %=     | 取**模** (余数)赋值运算符 | c %= a 等效于 c = c % a               |
| **=    | 幂赋值运算符              | c **= a 等效于 c = c ** a             |

### 2.3 Python 中的计数方法

常见的计数方法有两种，可以分别称为：

- **自然计数法**（从 `1` 开始）—— 更符合人类的习惯
- **程序计数法**（从 `0` 开始）—— 几乎所有的程序语言都选择从 0 开始计数

因此，大家在编写程序时，应该尽量养成习惯：**除非需求的特殊要求，否则 循环 的计数都从 0 开始**

### 2.4 循环计算

> 在程序开发中，通常会遇到 利用循环 重复计算 的需求
> 

遇到这种需求，可以：

1. 在 `while` 上方定义一个变量，用于 **存放最终计算结果**
2. 在循环体内部，每次循环都用 **最新的计算结果**，**更新** 之前定义的变量

**需求**

- 计算 0 ~ 100 之间所有数字的累计求和结果

```python
# 计算 0 ~ 100 之间所有数字的累计求和结果
# 0. 定义最终结果的变量
result = 0

# 1. 定义一个整数的变量记录循环的次数
i = 0

# 2. 开始循环
while i <= 100:
print(i)

# 每一次循环，都让 result 这个变量和 i 这个计数器相加
result += i

# 处理计数器
i += 1

print("0~100之间的数字求和结果 = %d" % result)

```

### 需求进阶

- 计算 0 ~ 100 之间 所有 **偶数** 的累计求和结果

开发步骤

1. 编写循环 **确认** **要计算的数字**
2. 添加 **结果** 变量，在循环内部 **处理计算结果**

```python
# 0. 最终结果
result = 0

# 1. 计数器
i = 0

# 2. 开始循环
while i <= 100:

# 判断偶数
if i % 2 == 0:
print(i)
result += i

# 处理计数器
i += 1

print("0~100之间偶数求和结果 = %d" % result)

```

## 3. break 和 continue

> break 和 continue 是专门在循环中使用的关键字
> 
- `break` **某一条件满足时**，退出循环，不再执行后续重复的代码
- `continue` **某一条件满足时**，不执行后续重复的代码

> break 和 continue 只针对 当前所在循环 有效
> 

### 3.1 break

- **在循环过程中**，如果 **某一个条件满足后**，**不** 再希望 **循环继续执行**，可以使用 `break` 退出循环

```python
i = 0

while i < 10:

# break 某一条件满足时，退出循环，不再执行后续重复的代码
# i == 3
if i == 3:
break

print(i)

i += 1

print("over")

```

> break 只针对当前所在循环有效
> 

### 3.2 continue

- **在循环过程中**，如果 **某一个条件满足后**，**不** 希望 **执行循环代码，但是又不希望退出循环**，可以使用 `continue`
- 也就是：在整个循环中，**只有某些条件**，不需要执行循环代码，而其他条件都需要执行

```python
i = 0

while i < 10:

# 当 i == 7 时，不希望执行需要重复执行的代码
if i == 7:
# 在使用 continue 之前，同样应该修改计数器
# 否则会出现死循环
i += 1

continue

# 重复执行的代码
print(i)

i += 1

```

- 需要注意：使用 `continue` 时，**条件处理部分的代码，需要特别注意**，不小心会出现 **死循环**

> continue 只针对当前所在循环有效
> 

## 4. `while` 循环嵌套

### 4.1 循环嵌套

- `while` 嵌套就是：`while` 里面还有 `while`

```python
while 条件 1:
条件满足时，做的事情1
条件满足时，做的事情2
条件满足时，做的事情3
...(省略)...

while 条件 2:
条件满足时，做的事情1
条件满足时，做的事情2
条件满足时，做的事情3
...(省略)...

处理条件 2

处理条件 1

```

### 4.2 循环嵌套演练 —— 九九乘法表

### 第 1 步：用嵌套打印小星星

**需求**

- 在控制台连续输出五行 ``，每一行星号的数量依次递增

```
*
**
***
****
*****

```

- 使用字符串 * 打印

```python
# 1. 定义一个计数器变量，从数字1开始，循环会比较方便
row = 1

while row <= 5:

print("*" * row)

row += 1

```

### 第 2 步：使用循环嵌套打印小星星

**知识点** 对 `print` 函数的使用做一个增强

- 在默认情况下，`print` 函数输出内容之后，会自动在内容末尾增加换行
- 如果不希望末尾增加换行，可以在 `print` 函数输出内容的后面增加 `, end=""`
- 其中 `""` 中间可以指定 `print` 函数输出内容之后，继续希望显示的内容
- 语法格式如下：

```python
# 向控制台输出内容结束之后，不会换行
print("*", end="")

# 单纯的换行
print("")

```

> end="" 表示向控制台输出内容结束之后，不会换行
> 

**假设** `Python` **没有提供** 字符串的 `*` 操作 **拼接字符串**

**需求**

- 在控制台连续输出五行 ``，每一行星号的数量依次递增

```
*
**
***
****
*****

```

**开发步骤**

- 1> 完成 5 行内容的简单输出
- 2> 分析每行内部的 `` 应该如何处理？
- 每行显示的星星和当前所在的行数是一致的
- 嵌套一个小的循环，专门处理每一行中 `列` 的星星显示

```python
row = 1

while row <= 5:

# 假设 python 没有提供字符串 * 操作
# 在循环内部，再增加一个循环，实现每一行的 星星 打印
col = 1

while col <= row:
print("*", end="")

col += 1

# 每一行星号输出完成后，再增加一个换行
print("")

row += 1

```

### 第 3 步： 九九乘法表

**需求** 输出 九九乘法表，格式如下：

```
1 * 1 = 1
1 * 2 = 2	2 * 2 = 4
1 * 3 = 3	2 * 3 = 6	3 * 3 = 9
1 * 4 = 4	2 * 4 = 8	3 * 4 = 12	4 * 4 = 16
1 * 5 = 5	2 * 5 = 10	3 * 5 = 15	4 * 5 = 20	5 * 5 = 25
1 * 6 = 6	2 * 6 = 12	3 * 6 = 18	4 * 6 = 24	5 * 6 = 30	6 * 6 = 36
1 * 7 = 7	2 * 7 = 14	3 * 7 = 21	4 * 7 = 28	5 * 7 = 35	6 * 7 = 42	7 * 7 = 49
1 * 8 = 8	2 * 8 = 16	3 * 8 = 24	4 * 8 = 32	5 * 8 = 40	6 * 8 = 48	7 * 8 = 56	8 * 8 = 64
1 * 9 = 9	2 * 9 = 18	3 * 9 = 27	4 * 9 = 36	5 * 9 = 45	6 * 9 = 54	7 * 9 = 63	8 * 9 = 72	9 * 9 = 81

```

**开发步骤**

- 打印 9 行小星星

```
*
**
***
****
*****
******
*******
********
*********

```

- 将每一个 `` 替换成对应的行与列相乘

```python
# 定义起始行
row = 1

# 最大打印 9 行
while row <= 9:
# 定义起始列
col = 1

# 最大打印 row 列
while col <= row:

# end = ""，表示输出结束后，不换行
# "\\t" 可以在控制台输出一个制表符，协助在输出文本时对齐
print("%d * %d = %d" % (col, row, row * col), end="\\t")

# 列数 + 1
col += 1

# 一行打印完成的换行
print("")

# 行数 + 1
row += 1

```

**字符串中的转义字符**

- `\\t` 在控制台输出一个 **制表符**，协助在输出文本时 **垂直方向** 保持对齐
- `\\n` 在控制台输出一个 **换行符**

> 制表符 的功能是在不使用表格的情况下在 垂直方向 按列对齐文本
> 

| 转义字符 | 描述       |
| -------- | ---------- |
| \\\\     | 反斜杠符号 |
| \\'      | 单引号     |
| \\"      | 双引号     |
| \n       | 换行       |
| \t       | 横向制表符 |
| \r       | 回车       |

# 八、函数基础

## 目标

- 函数的快速体验
- 函数的基本使用
- 函数的参数
- 函数的返回值
- 函数的嵌套调用
- 在模块中定义函数

## 1. 函数的快速体验

### 1.1 快速体验

- 所谓**函数**，就是把 **具有独立功能的代码块** 组织为一个小模块，在需要的时候 **调用**
- 函数的使用包含两个步骤：
1. 定义函数 —— **封装** 独立的功能
2. 调用函数 —— 享受 **封装** 的成果
- **函数的作用**，在开发程序时，使用函数可以提高编写的效率以及代码的 **重用**

**演练步骤**

1. 新建 `04_函数` 项目
2. 复制之前完成的 **乘法表** 文件
3. 修改文件，增加函数定义 `multiple_table():`
4. 新建另外一个文件，使用 `import` 导入并且调用函数

## 2. 函数基本使用

### 2.1 函数的定义

定义函数的格式如下：

```python
def 函数名():

函数封装的代码
……

```

5. `def` 是英文 `define` 的缩写
6. **函数名称** 应该能够表达 **函数封装代码** 的功能，方便后续的调用
7. **函数名称** 的命名应该 **符合** **标识符的命名规则**
- 可以由 **字母**、**下划线** 和 **数字** 组成
- **不能以数字开头**
- **不能与关键字重名**

### 2.2 函数调用

调用函数很简单的，通过 `函数名()` 即可完成对函数的调用

### 2.3 第一个函数演练

**需求**

- 编写一个打招呼 `say_hello` 的函数，封装三行打招呼的代码
- 在函数下方调用打招呼的代码

```python
name = "小明"

# 解释器知道这里定义了一个函数
def say_hello():
print("hello 1")
print("hello 2")
print("hello 3")

print(name)
# 只有在调用函数时，之前定义的函数才会被执行
# 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码
say_hello()

print(name)

```

> 用 单步执行 F8 和 F7 观察以下代码的执行过程
> 
- 定义好函数之后，只表示这个函数封装了一段代码而已
- 如果不主动调用函数，函数是不会主动执行的

### 思考

- 能否将 **函数调用** 放在 **函数定义** 的上方？
- 不能！
- 因为在 **使用函数名** 调用函数之前，必须要保证 `Python` 已经知道函数的存在
- 否则控制台会提示 `NameError: name 'say_hello' is not defined` (**名称错误：say_hello 这个名字没有被定义**)

### 2.4 PyCharm 的调试工具

- **F8 Step Over** 可以单步执行代码，会把函数调用看作是一行代码直接执行
- **F7 Step Into** 可以单步执行代码，如果是函数，会进入函数内部

### 2.5 函数的文档注释

- 在开发中，如果希望给函数添加注释，应该在 **定义函数** 的下方，使用 **连续的三对引号**
- 在 **连续的三对引号** 之间编写对函数的说明文字
- 在 **函数调用** 位置，使用快捷键 `CTRL + Q` 可以查看函数的说明信息

> 注意：因为 函数体相对比较独立，函数定义的上方，应该和其他代码（包括注释）保留 两个空行
> 

## 3. 函数的参数

**演练需求**

1. 开发一个 `sum_2_num` 的函数
2. 函数能够实现 **两个数字的求和** 功能

演练代码如下：

```python
def sum_2_num():

num1 = 10
num2 = 20
result = num1 + num2

print("%d + %d = %d" % (num1, num2, result))

sum_2_num()

```

**思考一下存在什么问题**

> 函数只能处理 固定数值 的相加
> 

**如何解决？**

- 如果能够把需要计算的数字，在调用函数时，传递到函数内部就好了！

### 3.1 函数参数的使用

- 在函数名的后面的小括号内部填写 **参数**
- 多个参数之间使用 `,` 分隔

```python
def sum_2_num(num1, num2):

result = num1 + num2

print("%d + %d = %d" % (num1, num2, result))

sum_2_num(50, 20)

```

### 3.2 参数的作用

- **函数**，把 **具有独立功能的代码块** 组织为一个小模块，在需要的时候 **调用**
- **函数的参数**，增加函数的 **通用性**，针对 **相同的数据处理逻辑**，能够 **适应更多的数据**
1. 在函数 **内部**，把参数当做 **变量** 使用，进行需要的数据处理
2. 函数调用时，按照函数定义的**参数顺序**，把 **希望在函数内部处理的数据**，**通过参数** 传递

### 3.3 形参和实参

- **形参**：**定义** 函数时，小括号中的参数，是用来接收参数用的，在函数内部 **作为变量使用**
- **实参**：**调用** 函数时，小括号中的参数，是用来把数据传递到 **函数内部** 用的

## 4. 函数的返回值

- 在程序开发中，有时候，会希望 **一个函数执行结束后，告诉调用者一个结果**，以便调用者针对具体的结果做后续的处理
- **返回值** 是函数 **完成工作**后，**最后** 给调用者的 **一个结果**
- 在函数中使用 `return` 关键字可以返回结果
- 调用函数一方，可以 **使用变量** 来 **接收** 函数的返回结果

> 注意：return 表示返回，后续的代码都不会被执行
> 

```python
def sum_2_num(num1, num2):
"""对两个数字的求和"""

return num1 + num2

# 调用函数，并使用 result 变量接收计算结果
result = sum_2_num(10, 20)

print("计算结果是 %d" % result)

```

## 5. 函数的嵌套调用

- 一个函数里面 **又调用** 了 **另外一个函数**，这就是 **函数嵌套调用**
- 如果函数 `test2` 中，调用了另外一个函数 `test1`
- 那么执行到调用 `test1` 函数时，会先把函数 `test1` 中的任务都执行完
- 才会回到 `test2` 中调用函数 `test1` 的位置，继续执行后续的代码

```python
def test1():

print("*" * 50)
print("test 1")
print("*" * 50)

def test2():

print("-" * 50)
print("test 2")

test1()

print("-" * 50)

test2()

```

### 函数嵌套的演练 —— 打印分隔线

> 体会一下工作中 需求是多变 的
> 

**需求 1**

- 定义一个 `print_line` 函数能够打印 `` 组成的 **一条分隔线**

```python
def print_line(char):

print("*" * 50)

```

**需求 2**

- 定义一个函数能够打印 **由任意字符组成** 的分隔线

```python
def print_line(char):

print(char * 50)

```

**需求 3**

- 定义一个函数能够打印 **任意重复次数** 的分隔线

```python
def print_line(char, times):

print(char * times)

```

**需求 4**

- 定义一个函数能够打印 **5 行** 的分隔线，分隔线要求符合**需求 3**

> 提示：工作中针对需求的变化，应该冷静思考，不要轻易修改之前已经完成的，能够正常执行的函数！
> 

```python
def print_line(char, times):

print(char * times)

def print_lines(char, times):

row = 0

while row < 5:
print_line(char, times)

row += 1

```

## 6. 使用模块中的函数

> 模块是 Python 程序架构的一个核心概念
> 
- **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要 **导入 import** 这个模块
- 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
- 在模块中定义的 **全局变量** 、 **函数** 都是模块能够提供给外界直接使用的工具

### 6.1 第一个模块体验

**步骤**

- 新建 `hm_10_分隔线模块.py`
- 复制 `hm_09_打印多条分隔线.py` 中的内容，**最后一行 `print` 代码除外**
- 增加一个字符串变量

```python
name = "黑马程序员"

```

- 新建 `hm_10_体验模块.py` 文件，并且编写以下代码：

```python
import hm_10_分隔线模块

hm_10_分隔线模块.print_line("-", 80)
print(hm_10_分隔线模块.name)

```

### 体验小结

- 可以 **在一个 Python 文件** 中 **定义 变量 或者 函数**
- 然后在 **另外一个文件中** 使用 `import` 导入这个模块
- 导入之后，就可以使用 `模块名.变量` / `模块名.函数` 的方式，使用这个模块中定义的变量或者函数

> 模块可以让 曾经编写过的代码 方便的被 复用！
> 

### 6.2 模块名也是一个标识符

- 标示符可以由 **字母**、**下划线** 和 **数字** 组成
- **不能以数字开头**
- **不能与关键字重名**

> 注意：如果在给 Python 文件起名时，以数字开头 是无法在 PyCharm 中通过导入这个模块的
> 

### 6.3 Pyc 文件（了解）

> C 是 compiled 编译过 的意思
> 

**操作步骤**

1. 浏览程序目录会发现一个 `__pycache__` 的目录
2. 目录下会有一个 `hm_10_分隔线模块.cpython-35.pyc` 文件，`cpython-35` 表示 `Python` 解释器的版本
3. 这个 `pyc` 文件是由 Python 解释器将 **模块的源码** 转换为 **字节码**
- `Python` 这样保存 **字节码** 是作为一种启动 **速度的优化**

**字节码**

- `Python` 在解释源程序时是分成两个步骤的
1. 首先处理源代码，**编译** 生成一个二进制 **字节码**
2. 再对 **字节码** 进行处理，才会生成 CPU 能够识别的 **机器码**
- 有了模块的字节码文件之后，下一次运行程序时，如果在 **上次保存字节码之后** 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤
- 当 `Python` 重编译时，它会自动检查源文件和字节码文件的时间戳
- 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

> 提示：有关模块以及模块的其他导入方式，后续课程还会逐渐展开！
> 
> 
> **模块是 Python 程序架构的一个核心概念**
> 

# 九、高级变量类型

## 目标

- 列表
- 元组
- 字典
- 字符串
- 公共方法
- 变量高级

### 知识点回顾

- Python 中数据类型可以分为 **数字型** 和 **非数字型**
- 数字型
- 整型 (`int`)
- 浮点型（`float`）
- 布尔型（`bool`）
- 真 `True` `非 0 数` —— **非零即真**
- 假 `False` `0`
- 复数型 (`complex`)
- 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题
- 非数字型
- 字符串
- 列表
- 元组
- 字典
- 在 `Python` 中，所有 **非数字型变量** 都支持以下特点：
1. 都是一个 **序列** `sequence`，也可以理解为 **容器**
2. **取值** `[]`
3. **遍历** `for in`
4. **计算长度**、**最大/最小值**、**比较**、**删除**
5. **链接** `+` 和 **重复** ``
6. **切片**

## 1. 列表

### 1.1 列表的定义

- `List`（列表） 是 `Python` 中使用 **最频繁** 的数据类型，在其他语言中通常叫做 **数组**
- 专门用于存储 **一串 信息**
- 列表用 `[]` 定义，**数据** 之间使用 `,` 分隔
- 列表的 **索引** 从 `0` 开始
- **索引** 就是数据在 **列表** 中的位置编号，**索引** 又可以被称为 **下标**

> 注意：从列表中取值时，如果 超出索引范围，程序会报错
> 

```python
name_list = ["zhangsan", "lisi", "wangwu"]

```

### 1.2 列表常用操作

- 在 `ipython3` 中定义一个 **列表**，例如：`name_list = []`
- 输入 `name_list.` 按下 `TAB` 键，`ipython` 会提示 **列表** 能够使用的 **方法** 如下：

```
In [1]: name_list.
name_list.append   name_list.count    name_list.insert   name_list.reverse
name_list.clear    name_list.extend   name_list.pop      name_list.sort
name_list.copy     name_list.index    name_list.remove

```

| 序号 | 分类 | 关键字 / 函数 / 方法    | 说明                     |
| ---- | ---- | ----------------------- | ------------------------ |
| 1    | 增加 | 列表.insert(索引, 数据) | 在指定位置插入数据       |
|      |      | 列表.append(数据)       | 在末尾追加数据           |
|      |      | 列表.extend(列表2)      | 将列表2 的数据追加到列表 |
| 2    | 修改 | 列表[索引] = 数据       | 修改指定索引的数据       |
| 3    | 删除 | del 列表[索引]          | 删除指定索引的数据       |
|      |      | 列表.remove[数据]       | 删除第一个出现的指定数据 |
|      |      | 列表.pop                | 删除末尾数据             |
|      |      | 列表.pop(索引)          | 删除指定索引数据         |
|      |      | 列表.clear              | 清空列表                 |
| 4    | 统计 | len(列表)               | 列表长度                 |
|      |      | 列表.count(数据)        | 数据在列表中出现的次数   |
| 5    | 排序 | 列表.sort()             | 升序排序                 |
|      |      | 列表.sort(reverse=True) | 降序排序                 |
|      |      | 列表.reverse()          | 逆序、反转               |

### del 关键字（科普）

- 使用 `del` 关键字(`delete`) 同样可以删除列表中元素
- `del` 关键字本质上是用来 **将一个变量从内存中删除的**
- 如果使用 `del` 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了

```python
del name_list[1]

```

> 在日常开发中，要从列表删除数据，建议 使用列表提供的方法
> 

### 关键字、函数和方法（科普）

- **关键字** 是 Python 内置的、具有特殊意义的标识符

```python
In [1]: import keyword
In [2]: print(keyword.kwlist)
In [3]: print(len(keyword.kwlist))

```

> 关键字后面不需要使用括号
> 
- **函数** 封装了独立功能，可以直接调用

```python
函数名(参数)

```

> 函数需要死记硬背
> 
- **方法** 和函数类似，同样是封装了独立的功能
- **方法** 需要通过 **对象** 来调用，表示针对这个 **对象** 要做的操作

```python
对象.方法名(参数)

```

> 在变量后面输入 .，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多
> 

### 1.3 循环遍历

- **遍历** 就是 **从头到尾** **依次** 从 **列表** 中获取数据
- 在 **循环体内部** 针对 **每一个元素**，执行相同的操作
- 在 `Python` 中为了提高列表的遍历效率，专门提供的 **迭代 iteration 遍历**
- 使用 `for` 就能够实现迭代遍历

```python
# for 循环内部使用的变量 in 列表
for name in name_list:

循环内部针对列表元素进行操作
print(name)

```

### 1.4 **应用场景**

- 尽管 `Python` 的 **列表** 中可以 **存储不同类型的数据**
- 但是在开发中，更多的应用场景是
1. **列表** 存储相同类型的数据
2. 通过 **迭代遍历**，在循环体内部，针对列表中的每一项元素，执行相同的操作

## 2. 元组

### 2.1 元组的定义

- `Tuple`（元组）与列表类似，不同之处在于元组的 **元素不能修改**
- **元组** 表示多个元素组成的序列
- **元组** 在 `Python` 开发中，有特定的应用场景
- 用于存储 **一串 信息**，**数据** 之间使用 `,` 分隔
- 元组用 `()` 定义
- 元组的 **索引** 从 `0` 开始
- **索引** 就是数据在 **元组** 中的位置编号

```python
info_tuple = ("zhangsan", 18, 1.75)

```

### 创建空元组

```python
info_tuple = ()

```

### 元组中 **只包含一个元素** 时，需要 **在元素后面添加逗号**

```python
info_tuple = (50, )

```

### 2.2 元组常用操作

- 在 `ipython3` 中定义一个 **元组**，例如：`info = ()`
- 输入 `info.` 按下 `TAB` 键，`ipython` 会提示 **元组** 能够使用的函数如下：

```python
info.count  info.index

```

> 有关 元组 的 常用操作 可以参照上图练习
> 

### 2.3 循环遍历

- **取值** 就是从 **元组** 中获取存储在指定位置的数据
- **遍历** 就是 **从头到尾** **依次** 从 **元组** 中获取数据

```python
# for 循环内部使用的变量 in 元组
for item in info:

循环内部针对元组元素进行操作
print(item)

```

> 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典 以及 字符串提示：在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多
> 

### 2.4 应用场景

- 尽管可以使用 `for in` 遍历 **元组**
- 但是在开发中，更多的应用场景是：
- **函数的 参数 和 返回值**，一个函数可以接收 **任意多个参数**，或者 **一次返回多个数据**
- 有关 **函数的参数 和 返回值**，在后续 **函数高级** 给大家介绍
- **格式字符串**，格式化字符串后面的 `()` 本质上就是一个元组
- **让列表不可以被修改**，以保护数据安全

```python
info = ("zhangsan", 18)

print("%s 的年龄是 %d" % info)

```

### 元组和列表之间的转换

- 使用 `list` 函数可以把元组转换成列表

```python
list(元组)

```

- 使用 `tuple` 函数可以把列表转换成元组

```python
tuple(列表)

```

## 3. 字典

### 3.1 字典的定义

- `dictionary`（字典） 是 **除列表以外** `Python` 之中 **最灵活** 的数据类型
- 字典同样可以用来 **存储多个数据**
- 通常用于存储 **描述一个 `物体` 的相关信息**
- 和列表的区别
- **列表** 是 **有序** 的对象集合
- **字典** 是 **无序** 的对象集合
- 字典用 `{}` 定义
- 字典使用 **键值对** 存储数据，键值对之间使用 `,` 分隔
- **键** `key` 是索引
- **值** `value` 是数据
- **键** 和 **值** 之间使用 `:` 分隔
- **键必须是唯一的**
- **值** 可以取任何数据类型，但 **键** 只能使用 **字符串**、**数字**或 **元组**

```python
xiaoming = {"name": "小明",
"age": 18,
"gender": True,
"height": 1.75}

```

### 3.2 字典常用操作

- 在 `ipython3` 中定义一个 **字典**，例如：`xiaoming = {}`
- 输入 `xiaoming.` 按下 `TAB` 键，`ipython` 会提示 **字典** 能够使用的函数如下：

```
In [1]: xiaoming.
xiaoming.clear       xiaoming.items       xiaoming.setdefault
xiaoming.copy        xiaoming.keys        xiaoming.update
xiaoming.fromkeys    xiaoming.pop         xiaoming.values
xiaoming.get         xiaoming.popitem

```

> 有关 字典 的 常用操作 可以参照上图练习
> 

### 3.3 循环遍历

- **遍历** 就是 **依次** 从 **字典** 中获取所有键值对

```python
# for 循环内部使用的 `key 的变量` in 字典
for k in xiaoming:

print("%s: %s" % (k, xiaoming[k]))

```

> 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多
> 

### 3.4 **应用场景**

- 尽管可以使用 `for in` 遍历 **字典**
- 但是在开发中，更多的应用场景是：
- 使用 **多个键值对**，存储 **描述一个 `物体` 的相关信息** —— 描述更复杂的数据信息
- 将 **多个字典** 放在 **一个列表** 中，再进行遍历，在循环体内部针对每一个字典进行 **相同的处理**

```python
card_list = [{"name": "张三",
"qq": "12345",
"phone": "110"},
{"name": "李四",
"qq": "54321",
"phone": "10086"}
]

```

## 4. 字符串

### 4.1 字符串的定义

- **字符串** 就是 **一串字符**，是编程语言中表示文本的数据类型
- 在 Python 中可以使用 **一对双引号** `"` 或者 **一对单引号** `'` 定义一个字符串
- 虽然可以使用 `\\"` 或者 `\\'` 做字符串的转义，但是在实际开发中：
- 如果字符串内部需要使用 `"`，可以使用 `'` 定义字符串
- 如果字符串内部需要使用 `'`，可以使用 `"` 定义字符串
- 可以使用 **索引** 获取一个字符串中 **指定位置的字符**，索引计数从 **0** 开始
- 也可以使用 `for` **循环遍历** 字符串中每一个字符

> 大多数编程语言都是用 " 来定义字符串
> 

```python
string = "Hello Python"

for c in string:
print(c)

```

### 4.2 字符串的常用操作

- 在 `ipython3` 中定义一个 **字符串**，例如：`hello_str = ""`
- 输入 `hello_str.` 按下 `TAB` 键，`ipython` 会提示 **字符串** 能够使用的 **方法** 如下：

```
In [1]: hello_str.
hello_str.capitalize    hello_str.isidentifier  hello_str.rindex
hello_str.casefold      hello_str.islower       hello_str.rjust
hello_str.center        hello_str.isnumeric     hello_str.rpartition
hello_str.count         hello_str.isprintable   hello_str.rsplit
hello_str.encode        hello_str.isspace       hello_str.rstrip
hello_str.endswith      hello_str.istitle       hello_str.split
hello_str.expandtabs    hello_str.isupper       hello_str.splitlines
hello_str.find          hello_str.join          hello_str.startswith
hello_str.format        hello_str.ljust         hello_str.strip
hello_str.format_map    hello_str.lower         hello_str.swapcase
hello_str.index         hello_str.lstrip        hello_str.title
hello_str.isalnum       hello_str.maketrans     hello_str.translate
hello_str.isalpha       hello_str.partition     hello_str.upper
hello_str.isdecimal     hello_str.replace       hello_str.zfill
hello_str.isdigit       hello_str.rfind

```

> 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！
> 

### 1) 判断类型 - 9

| 方法               | 说明                                                                                            |
| ------------------ | ----------------------------------------------------------------------------------------------- |
| string.isspace()   | 如果 string 中只包含空格，则返回 True                                                           |
| string.isalnum()   | 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True                                 |
| string.isalpha()   | 如果 string 至少有一个字符并且所有字符都是字母则返回 True                                       |
| string.isdecimal() | 如果 string 只包含数字则返回 True，`全角数字`                                                   |
| string.isdigit()   | 如果 string 只包含数字则返回 True，`全角数字`、`⑴`、`\\u00b2`                                   |
| string.isnumeric() | 如果 string 只包含数字则返回 True，`全角数字`，`汉字数字`                                       |
| string.istitle()   | 如果 string 是标题化的(每个单词的首字母大写)则返回 True                                         |
| string.islower()   | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True |
| string.isupper()   | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True |

### 2) 查找和替换 - 7

| 方法                                                    | 说明                                                                                                                         |
| ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| string.startswith(str)                                  | 检查字符串是否是以 str 开头，是则返回 True                                                                                   |
| string.endswith(str)                                    | 检查字符串是否是以 str 结束，是则返回 True                                                                                   |
| string.find(str, start=0, end=len(string))              | 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 `-1` |
| string.rfind(str, start=0, end=len(string))             | 类似于 find()，不过是从右边开始查找                                                                                          |
| string.index(str, start=0, end=len(string))             | 跟 find() 方法类似，不过如果 str 不在 string 会报错                                                                          |
| string.rindex(str, start=0, end=len(string))            | 类似于 index()，不过是从右边开始                                                                                             |
| string.replace(old_str, new_str, num=string.count(old)) | 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次                                                    |

### 3) 大小写转换 - 5

| 方法                | 说明                             |
| ------------------- | -------------------------------- |
| string.capitalize() | 把字符串的第一个字符大写         |
| string.title()      | 把字符串的每个单词首字母大写     |
| string.lower()      | 转换 string 中所有大写字符为小写 |
| string.upper()      | 转换 string 中的小写字母为大写   |
| string.swapcase()   | 翻转 string 中的大小写           |

### 4) 文本对齐 - 3

| 方法                 | 说明                                                          |
| -------------------- | ------------------------------------------------------------- |
| string.ljust(width)  | 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 |
| string.rjust(width)  | 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 |
| string.center(width) | 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串   |

### 5) 去除空白字符 - 3

| 方法            | 说明                               |
| --------------- | ---------------------------------- |
| string.lstrip() | 截掉 string 左边（开始）的空白字符 |
| string.rstrip() | 截掉 string 右边（末尾）的空白字符 |
| string.strip()  | 截掉 string 左右两边的空白字符     |

### 6) 拆分和连接 - 5

| 方法                      | 说明                                                                                                             |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| string.partition(str)     | 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)                                                    |
| string.rpartition(str)    | 类似于 partition() 方法，不过是从右边开始查找                                                                    |
| string.split(str="", num) | 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\r', '\t', '\n' 和空格 |
| string.splitlines()       | 按照行('\r', '\n', '\r\n')分隔，返回一个包含各行作为元素的列表                                                   |
| string.join(seq)          | 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串                                    |

### 4.3 字符串的切片

- **切片** 方法适用于 **字符串**、**列表**、**元组**
- **切片** 使用 **索引值** 来限定范围，从一个大的 **字符串** 中 **切出** 小的 **字符串**
- **列表** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据
- **字典** 是一个 **无序** 的集合，是使用 **键值对** 保存数据

```
字符串[开始索引:结束索引:步长]

```

**注意**：

1. 指定的区间属于 **左闭右开** 型 `[开始索引, 结束索引)` => `开始索引 >= 范围 < 结束索引`
- 从 `起始` 位开始，到 **`结束`位的前一位** 结束（**不包含结束位本身**)
2. 从头开始，**开始索引** **数字可以省略，冒号不能省略**
3. 到末尾结束，**结束索引** **数字可以省略，冒号不能省略**
4. 步长默认为 `1`，如果连续切片，**数字和冒号都可以省略**

### 索引的顺序和倒序

- 在 Python 中不仅支持 **顺序索引**，同时还支持 **倒序索引**
- 所谓倒序索引就是 **从右向左** 计算索引
- 最右边的索引值是 **1**，依次递减

**演练需求**

- 截取从 2 ~ 5 位置 的字符串
- 截取从 2 ~ `末尾` 的字符串
- 截取从 `开始` ~ 5 位置 的字符串
- 截取完整的字符串
- 从开始位置，每隔一个字符截取字符串
- 从索引 1 开始，每隔一个取一个
- 截取从 2 ~ `末尾 - 1` 的字符串
- 截取字符串末尾两个字符
- 字符串的逆序（面试题）

**答案**

```
num_str = "0123456789"

# 1. 截取从 2 ~ 5 位置 的字符串
print(num_str[2:6])

# 2. 截取从 2 ~ `末尾` 的字符串
print(num_str[2:])

# 3. 截取从 `开始` ~ 5 位置 的字符串
print(num_str[:6])

# 4. 截取完整的字符串
print(num_str[:])

# 5. 从开始位置，每隔一个字符截取字符串
print(num_str[::2])

# 6. 从索引 1 开始，每隔一个取一个
print(num_str[1::2])

# 倒序切片
# -1 表示倒数第一个字符
print(num_str[-1])

# 7. 截取从 2 ~ `末尾 - 1` 的字符串
print(num_str[2:-1])

# 8. 截取字符串末尾两个字符
print(num_str[-2:])

# 9. 字符串的逆序（面试题）
print(num_str[::-1])

```

## 5. 公共方法

### 5.1 Python 内置函数

Python 包含了以下内置函数：

| 函数              | 描述                              | 备注                        |
| ----------------- | --------------------------------- | --------------------------- |
| len(item)         | 计算容器中元素个数                |                             |
| del(item)         | 删除变量                          | del 有两种方式              |
| max(item)         | 返回容器中元素最大值              | 如果是字典，只针对 key 比较 |
| min(item)         | 返回容器中元素最小值              | 如果是字典，只针对 key 比较 |
| cmp(item1, item2) | 比较两个值，-1 小于/0 相等/1 大于 | Python 3.x 取消了 cmp 函数  |

**注意**

- **字符串** 比较符合以下规则： "0" < "A" < "a"

### 5.2 切片

| 描述 | Python 表达式      | 结果    | 支持的数据类型     |     |
| ---- | ------------------ | ------- | ------------------ | --- |
| 切片 | "0123456789"[::-2] | "97531" | 字符串、列表、元组 |     |
- **切片** 使用 **索引值** 来限定范围，从一个大的 **字符串** 中 **切出** 小的 **字符串**
- **列表** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据
- **字典** 是一个 **无序** 的集合，是使用 **键值对** 保存数据

### 5.3 运算符

| 运算符       | Python 表达式         | 结果                         | 描述           | 支持的数据类型           |
| ------------ | --------------------- | ---------------------------- | -------------- | ------------------------ |
| +            | [1, 2] + [3, 4]       | [1, 2, 3, 4]                 | 合并           | 字符串、列表、元组       |
| *            | ["Hi!"] * 4           | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 重复           | 字符串、列表、元组       |
| in           | 3 in (1, 2, 3)        | True                         | 元素是否存在   | 字符串、列表、元组、字典 |
| not in       | 4 not in (1, 2, 3)    | True                         | 元素是否不存在 | 字符串、列表、元组、字典 |
| > >= == < <= | (1, 2, 3) < (2, 2, 3) | True                         | 元素比较       | 字符串、列表、元组       |

**注意**

- `in` 在对 **字典** 操作时，判断的是 **字典的键**
- `in` 和 `not in` 被称为 **成员运算符**

### 成员运算符

成员运算符用于 **测试** 序列中是否包含指定的 **成员**

| 运算符 | 描述                                                  | 实例                              |
| ------ | ----------------------------------------------------- | --------------------------------- |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False     | `3 in (1, 2, 3)` 返回 `True`      |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False | `3 not in (1, 2, 3)` 返回 `False` |

注意：在对 **字典** 操作时，判断的是 **字典的键**

### 5.4 完整的 for 循环语法

- 在 `Python` 中完整的 `for 循环` 的语法如下：

```python
for 变量 in 集合:

循环体代码
else:
没有通过 break 退出循环，循环结束后，会执行的代码

```

### 应用场景

- 在 **迭代遍历** 嵌套的数据类型时，例如 **一个列表包含了多个字典**
- 需求：要判断 某一个字典中 是否存在 指定的 值
- 如果 **存在**，提示并且退出循环
- 如果 **不存在**，在 **循环整体结束** 后，希望 **得到一个统一的提示**

```python
students = [
{"name": "阿土",
"age": 20,
"gender": True,
"height": 1.7,
"weight": 75.0},
{"name": "小美",
"age": 19,
"gender": False,
"height": 1.6,
"weight": 45.0},
]

find_name = "阿土"

for stu_dict in students:

print(stu_dict)

# 判断当前遍历的字典中姓名是否为find_name
if stu_dict["name"] == find_name:
print("找到了")

# 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较
break

else:
print("没有找到")

print("循环结束")

```

# 十、变量进阶（理解）

## 目标

- 变量的引用
- 可变和不可变类型
- 局部变量和全局变量

## 1. 变量的引用

> 变量 和 数据 都是保存在 内存 中的在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的
> 

### 1.1 引用的概念

在 `Python` 中

- **变量** 和 **数据** 是分开存储的
- **数据** 保存在内存中的一个位置
- **变量** 中保存着数据在内存中的地址
- **变量** 中 **记录数据的地址**，就叫做 **引用**
- 使用 `id()` 函数可以查看变量中保存数据所在的 **内存地址**

> 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用
> 
> - 变量 **不再** 对之前的数据引用
> - 变量 **改为** 对新赋值的数据引用

### 1.2 `变量引用` 的示例

在 `Python` 中，变量的名字类似于 **便签纸** 贴在 **数据** 上

- 定义一个整数变量 `a`，并且赋值为 `1`
- 将变量 `a` 赋值为 `2`
- 定义一个整数变量 `b`，并且将变量 `a` 的值赋值给 `b`

> 变量 b 是第 2 个贴在数字 2 上的标签
> 

### 1.3 函数的参数和返回值的传递

在 `Python` 中，函数的 **实参**/**返回值** 都是是靠 **引用** 来传递来的

```python
def test(num):

print("-" * 50)
print("%d 在函数内的内存地址是 %x" % (num, id(num)))

result = 100

print("返回值 %d 在内存中的地址是 %x" % (result, id(result)))
print("-" * 50)

return  result

a = 10
print("调用函数前 内存地址是 %x" % id(a))

r = test(a)

print("调用函数后 实参内存地址是 %x" % id(a))
print("调用函数后 返回值内存地址是 %x" % id(r))

```

## 2. 可变和不可变类型

- **不可变类型**，内存中的数据不允许被修改：
- 数字类型 `int`, `bool`, `float`, `complex`, `long(2.x)`
- 字符串 `str`
- 元组 `tuple`
- **可变类型**，内存中的数据可以被修改：
- 列表 `list`
- 字典 `dict`

```python
a = 1
a = "hello"
a = [1, 2, 3]
a = [3, 2, 1]

```

```python
demo_list = [1, 2, 3]

print("定义列表后的内存地址 %d" % id(demo_list))

demo_list.append(999)
demo_list.pop(0)
demo_list.remove(2)
demo_list[0] = 10

print("修改数据后的内存地址 %d" % id(demo_list))

demo_dict = {"name": "小明"}

print("定义字典后的内存地址 %d" % id(demo_dict))

demo_dict["age"] = 18
demo_dict.pop("name")
demo_dict["name"] = "老王"

print("修改数据后的内存地址 %d" % id(demo_dict))

```

> 注意：字典的 key 只能使用不可变类型的数据
> 

**注意**

1. **可变类型**的数据变化，是通过 **方法** 来实现的
2. 如果给一个可变类型的变量，赋值了一个新的数据，**引用会修改**
- 变量 **不再** 对之前的数据引用
- 变量 **改为** 对新赋值的数据引用

### 哈希 `(hash)`

- `Python` 中内置有一个名字叫做 `hash(o)` 的函数
- 接收一个 **不可变类型** 的数据作为 **参数**
- **返回** 结果是一个 **整数**
- `哈希` 是一种 **算法**，其作用就是提取数据的 **特征码（指纹）**
- **相同的内容** 得到 **相同的结果**
- **不同的内容** 得到 **不同的结果**
- 在 `Python` 中，设置字典的 **键值对** 时，会首先对 `key` 进行 `hash` 已决定如何在内存中保存字典的数据，以方便 **后续** 对字典的操作：**增、删、改、查**
- 键值对的 `key` 必须是不可变类型数据
- 键值对的 `value` 可以是任意类型的数据

## 3. 局部变量和全局变量

- **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**
- **全局变量** 是在 **函数外部定义** 的变量（没有定义在某一个函数内），**所有函数** 内部 **都可以使用这个变量**

> 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！
> 

### 3.1 局部变量

- **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**
- 函数执行结束后，**函数内部的局部变量，会被系统回收**
- 不同的函数，可以定义相同的名字的局部变量，但是 **彼此之间** 不会产生影响

### 局部变量的作用

- 在函数内部使用，**临时** 保存 **函数内部需要使用的数据**

```python
def demo1():

num = 10

print(num)

num = 20

print("修改后 %d" % num)

def demo2():

num = 100

print(num)

demo1()
demo2()

print("over")

```

### 局部变量的生命周期

- 所谓 **生命周期** 就是变量从 **被创建** 到 **被系统回收** 的过程
- **局部变量** 在 **函数执行时** 才会被创建
- **函数执行结束后** 局部变量 **被系统回收**
- **局部变量在生命周期** 内，可以用来存储 **函数内部临时使用到的数据**

### 3.2 全局变量

- **全局变量** 是在 **函数外部定义** 的变量，所有函数内部都可以使用这个变量

```python
# 定义一个全局变量
num = 10

def demo1():

print(num)

def demo2():

print(num)

demo1()
demo2()

print("over")

```

**注意**：函数执行时，**需要处理变量时** 会：

1. **首先** 查找 **函数内部** 是否存在 **指定名称 的局部变量**，**如果有，直接使用**
2. 如果没有，查找 **函数外部** 是否存在 **指定名称 的全局变量**，**如果有，直接使用**
3. 如果还没有，程序报错！

### 1) 函数不能直接修改 `全局变量的引用`

- **全局变量** 是在 **函数外部定义** 的变量（没有定义在某一个函数内），**所有函数** 内部 **都可以使用这个变量**

> 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！
> 
- 在函数内部，可以 **通过全局变量的引用获取对应的数据**
- 但是，**不允许直接修改全局变量的引用** —— 使用赋值语句修改全局变量的值

```python
num = 10

def demo1():

print("demo1" + "-" * 50)

# 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已
num = 100
print(num)

def demo2():

print("demo2" + "-" * 50)
print(num)

demo1()
demo2()

print("over")

```

> 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值
> 

### 2) 在函数内部修改全局变量的值

- 如果在函数中需要修改全局变量，需要使用 `global` 进行声明

```python
num = 10

def demo1():

print("demo1" + "-" * 50)

# global 关键字，告诉 Python 解释器 num 是一个全局变量
global num
# 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已
num = 100
print(num)

def demo2():

print("demo2" + "-" * 50)
print(num)

demo1()
demo2()

print("over")

```

### 3) 全局变量定义的位置

- 为了保证所有的函数都能够正确使用到全局变量，应该 **将全局变量定义在其他函数的上方**

```python
a = 10

def demo():
print("%d" % a)
print("%d" % b)
print("%d" % c)

b = 20
demo()
c = 30

```

**注意**

- 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！

**代码结构示意图如下**

### 4) 全局变量命名的建议

- 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：
- 全局变量名前应该增加 `g_` 或者 `gl_` 的前缀

> 提示：具体的要求格式，各公司要求可能会有些差异
> 

# 十一、函数进阶

## 目标

- 函数参数和返回值的作用
- 函数的返回值 进阶
- 函数的参数 进阶
- 递归函数

## 1. 函数参数和返回值的作用

函数根据 **有没有参数** 以及 **有没有返回值**，可以 **相互组合**，一共有 **4 种** 组合形式

1. 无参数，无返回值
2. 无参数，有返回值
3. 有参数，无返回值
4. 有参数，有返回值

> 定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的！
> 
5. 如果函数 **内部处理的数据不确定**，就可以将外界的数据以参数传递到函数内部
6. 如果希望一个函数 **执行完成后，向外界汇报执行结果**，就可以增加函数的返回值

### 1.1 无参数，无返回值

此类函数，不接收参数，也没有返回值，应用场景如下：

7. **只是单纯地做一件事情**，例如 **显示菜单**
8. 在函数内部 **针对全局变量进行操作**，例如：**新建名片**，最终结果 **记录在全局变量** 中

> 注意：
> 
- 如果全局变量的数据类型是一个 **可变类型**，在函数内部可以使用 **方法** 修改全局变量的内容 —— **变量的引用不会改变**
- 在函数内部，**使用赋值语句** 才会 **修改变量的引用**

### 1.2 无参数，有返回值

此类函数，不接收参数，但是有返回值，应用场景如下：

- 采集数据，例如 **温度计**，返回结果就是当前的温度，而不需要传递任何的参数

### 1.3 有参数，无返回值

此类函数，接收参数，没有返回值，应用场景如下：

- 函数内部的代码保持不变，针对 **不同的参数 处理 不同的数据**
- 例如 **名片管理系统** 针对 **找到的名片** 做 **修改**、**删除** 操作

### 1.4 有参数，有返回值

此类函数，接收参数，同时有返回值，应用场景如下：

- 函数内部的代码保持不变，针对 **不同的参数 处理 不同的数据**，并且 **返回期望的处理结果**
- 例如 **名片管理系统** 使用 **字典默认值** 和 **提示信息** 提示用户输入内容
- 如果输入，返回输入内容
- 如果没有输入，返回字典默认值

## 2. 函数的返回值 进阶

- 在程序开发中，有时候，会希望 **一个函数执行结束后，告诉调用者一个结果**，以便调用者针对具体的结果做后续的处理
- **返回值** 是函数 **完成工作**后，**最后** 给调用者的 **一个结果**
- 在函数中使用 `return` 关键字可以返回结果
- 调用函数一方，可以 **使用变量** 来 **接收** 函数的返回结果

> 问题：一个函数执行后能否返回多个结果？
> 

### 示例 —— 温度和湿度测量

- 假设要开发一个函数能够同时返回当前的温度和湿度
- **先完成返回温度**的功能如下：

```python
def measure():
"""返回当前的温度"""

print("开始测量...")
temp = 39
print("测量结束...")

return temp

result = measure()
print(result)

```

- 在利用 **元组** 在返回温度的同时，也能够返回 **湿度**
- 改造如下：

```python
def measure():
"""返回当前的温度"""

print("开始测量...")
temp = 39
wetness = 10
print("测量结束...")

return (temp, wetness)

```

> 提示：如果一个函数返回的是元组，括号可以省略
> 

**技巧**

- 在 `Python` 中，可以 **将一个元组** 使用 **赋值语句** 同时赋值给 **多个变量**
- 注意：变量的数量需要和元组中的元素数量保持一致

```python
result = temp, wetness = measure()

```

### 面试题 —— 交换两个数字

**题目要求**

1. 有两个整数变量 `a = 6`, `b = 100`
2. 不使用其他变量，**交换两个变量的值**

### 解法 1 —— 使用其他变量

```python
# 解法 1 - 使用临时变量
c = b
b = a
a = c

```

### 解法 2 —— 不使用临时变量

```python
# 解法 2 - 不使用临时变量
a = a + b
b = a - b
a = a - b

```

### 解法 3 —— Python 专有，利用元组

```python
a, b = b, a

```

## 3. 函数的参数 进阶

### 3.1. 不可变和可变的参数

> 问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？ —— 不会！
> 
- 无论传递的参数是 **可变** 还是 **不可变**
- 只要 **针对参数** 使用 **赋值语句**，会在 **函数内部** 修改 **局部变量的引用**，**不会影响到 外部变量的引用**

```python
def demo(num, num_list):

print("函数内部")

# 赋值语句
num = 200
num_list = [1, 2, 3]

print(num)
print(num_list)

print("函数代码完成")

gl_num = 99
gl_list = [4, 5, 6]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)

```

> 问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据
> 

```python
def mutable(num_list):

# num_list = [1, 2, 3]
num_list.extend([1, 2, 3])

print(num_list)

gl_list = [6, 7, 8]
mutable(gl_list)
print(gl_list)

```

### 面试题 —— `+=`

- 在 `python` 中，列表变量调用 `+=` 本质上是在执行列表变量的 `extend` 方法，不会修改变量的引用

```python
def demo(num, num_list):

print("函数内部代码")

# num = num + num
num += num
# num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用
# 函数执行结束后，外部数据同样会发生变化
num_list += num_list

print(num)
print(num_list)
print("函数代码完成")

gl_num = 9
gl_list = [1, 2, 3]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)

```

### 3.2 缺省参数

- 定义函数时，可以给 **某个参数** 指定一个**默认值**，具有默认值的参数就叫做 **缺省参数**
- 调用函数时，如果没有传入 **缺省参数** 的值，则在函数内部使用定义函数时指定的 **参数默认值**
- 函数的缺省参数，**将常见的值设置为参数的缺省值**，从而 **简化函数的调用**
- 例如：对列表排序的方法

```python
gl_num_list = [6, 3, 9]

# 默认就是升序排序，因为这种应用需求更多
gl_num_list.sort()
print(gl_num_list)

# 只有当需要降序排序时，才需要传递 `reverse` 参数
gl_num_list.sort(reverse=True)
print(gl_num_list)

```

### 指定函数的缺省参数

- 在参数后使用赋值语句，可以指定参数的缺省值

```python
def print_info(name, gender=True):

gender_text = "男生"
if not gender:
gender_text = "女生"

print("%s 是 %s" % (name, gender_text))

```

**提示**

1. 缺省参数，需要使用 **最常见的值** 作为默认值！
2. 如果一个参数的值 **不能确定**，则不应该设置默认值，具体的数值在调用函数时，由外界传递！

### 缺省参数的注意事项

### 1) 缺省参数的定义位置

- **必须保证** **带有默认值的缺省参数** **在参数列表末尾**
- 所以，以下定义是错误的！

```python
def print_info(name, gender=True, title):

```

### 2) 调用带有多个缺省参数的函数

- 在 **调用函数时**，如果有 **多个缺省参数**，**需要指定参数名**，这样解释器才能够知道参数的对应关系！

```python
def print_info(name, title="", gender=True):
"""

:param title: 职位
:param name: 班上同学的姓名
:param gender: True 男生 False 女生
"""

gender_text = "男生"

if not gender:
gender_text = "女生"

print("%s%s 是 %s" % (title, name, gender_text))

# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！
print_info("小明")
print_info("老王", title="班长")
print_info("小美", gender=False)

```

### 3.3 多值参数（知道）

### 定义支持多值参数的函数

- 有时可能需要 **一个函数** 能够处理的参数 **个数** 是不确定的，这个时候，就可以使用 **多值参数**
- `python` 中有 **两种** 多值参数：
- 参数名前增加 **一个** `` 可以接收 **元组**
- 参数名前增加 **两个** `` 可以接收 **字典**
- 一般在给多值参数命名时，**习惯**使用以下两个名字
- `args` —— 存放 **元组** 参数，前面有一个 ``
- `*kwargs` —— 存放 **字典** 参数，前面有两个 ``
- `args` 是 `arguments` 的缩写，有变量的含义
- `kw` 是 `keyword` 的缩写，`kwargs` 可以记忆 **键值对参数**

```python
def demo(num, *args, **kwargs):

print(num)
print(args)
print(kwargs)

demo(1, 2, 3, 4, 5, name="小明", age=18, gender=True)

```

> 提示：多值参数 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码
> 

### 多值参数案例 —— 计算任意多个数字的和

**需求**

1. 定义一个函数 `sum_numbers`，可以接收的 **任意多个整数**
2. 功能要求：将传递的 **所有数字累加** 并且返回累加结果

```python
def sum_numbers(*args):

num = 0
# 遍历 args 元组顺序求和
for n in args:
num += n

return num

print(sum_numbers(1, 2, 3))

```

### 元组和字典的拆包（知道）

- 在调用带有多值参数的函数时，如果希望：
- 将一个 **元组变量**，直接传递给 `args`
- 将一个 **字典变量**，直接传递给 `kwargs`
- 就可以使用 **拆包**，简化参数的传递，**拆包** 的方式是：
- 在 **元组变量前**，增加 **一个** ``
- 在 **字典变量前**，增加 **两个** ``

```python
def demo(*args, **kwargs):

print(args)
print(kwargs)

# 需要将一个元组变量/字典变量传递给函数对应的参数
gl_nums = (1, 2, 3)
gl_xiaoming = {"name": "小明", "age": 18}

# 会把 num_tuple 和 xiaoming 作为元组传递个 args
# demo(gl_nums, gl_xiaoming)
demo(*gl_nums, **gl_xiaoming)

```

## 4. 函数的递归

> 函数调用自身的 编程技巧 称为递归
> 

### 4.1 递归函数的特点

**特点**

- **一个函数** **内部** **调用自己**
- 函数内部可以调用其他函数，当然在函数内部也可以调用自己

**代码特点**

1. 函数内部的 **代码** 是相同的，只是针对 **参数** 不同，**处理的结果不同**
2. 当 **参数满足一个条件** 时，函数不再执行
- **这个非常重要**，通常被称为递归的出口，否则 **会出现死循环**！

示例代码

```python
def sum_numbers(num):

print(num)

# 递归的出口很重要，否则会出现死循环
if num == 1:
return

sum_numbers(num - 1)

sum_numbers(3)

```

### 4.2 递归案例 —— 计算数字累加

**需求**

3. 定义一个函数 `sum_numbers`
4. 能够接收一个 `num` 的整数参数
5. 计算 1 + 2 + ... num 的结果

```python
def sum_numbers(num):

if num == 1:
return 1

# 假设 sum_numbers 能够完成 num - 1 的累加
temp = sum_numbers(num - 1)

# 函数内部的核心算法就是 两个数字的相加
return num + temp

print(sum_numbers(2))

```

> 提示：递归是一个 编程技巧，初次接触递归会感觉有些吃力！在处理 不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构
> 

# 十二、面相对象基础语法

## 目标

- `dir` 内置函数
- 定义简单的类（只包含方法）
- 方法中的 `self` 参数
- 初始化方法
- 内置方法和属性

## 1. `dir` 内置函数（知道）

- 在 `Python` 中 **对象几乎是无所不在的**，我们之前学习的 **变量**、**数据**、**函数** 都是对象

在 `Python` 中可以使用以下两个方法验证：

1. 在 **标识符** / **数据** 后输入一个 `.`，然后按下 `TAB` 键，`iPython` 会提示该对象能够调用的 **方法列表**
2. 使用内置函数 `dir` 传入 **标识符** / **数据**，可以查看对象内的 **所有属性及方法**

**提示** `__方法名__` 格式的方法是 `Python` 提供的 **内置方法 / 属性**，稍后会给大家介绍一些常用的 内置方法 / 属性

| 序号 | 方法名     | 类型 | 作用                                         |
| ---- | ---------- | ---- | -------------------------------------------- |
| 01   | `__new__`  | 方法 | **创建对象**时，会被 **自动** 调用           |
| 02   | `__init__` | 方法 | **对象被初始化**时，会被 **自动** 调用       |
| 03   | `__del__`  | 方法 | **对象被从内存中销毁**前，会被 **自动** 调用 |
| 04   | `__str__`  | 方法 | 返回**对象的描述信息**，`print` 函数输出使用 |

**提示** 利用好 `dir()` 函数，在学习时很多内容就不需要死记硬背了

## 2. 定义简单的类（只包含方法）

> 面向对象 是 更大 的 封装，在 一个类中 封装 多个方法，这样 通过这个类创建出来的对象，就可以直接调用这些方法了！
> 

### 2.1 定义只包含方法的类

- 在 `Python` 中要定义一个只包含方法的类，语法格式如下：

```python
class 类名:

def 方法1(self, 参数列表):
pass

def 方法2(self, 参数列表):
pass

```

- **方法** 的定义格式和之前学习过的**函数** 几乎一样
- 区别在于第一个参数必须是 `self`，大家暂时先记住，稍后介绍 `self`

> 注意：类名 的 命名规则 要符合 大驼峰命名法
> 

### 2.2 创建对象

- 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：

```python
对象变量 = 类名()

```

### 2.3 第一个面向对象程序

**需求**

- **小猫** 爱 **吃** 鱼，**小猫** 要 **喝** 水

**分析**

1. 定义一个猫类 `Cat`
2. 定义两个方法 `eat` 和 `drink`
3. 按照需求 —— 不需要定义属性

```python
class Cat:
"""这是一个猫类"""

def eat(self):
print("小猫爱吃鱼")

def drink(self):
print("小猫在喝水")

tom = Cat()
tom.drink()
tom.eat()

```

### 引用概念的强调

> 在面向对象开发中，引用的概念是同样适用的！
> 
- 在 `Python` 中使用类 **创建对象之后**，`tom` 变量中 仍然记录的是 **对象在内存中的地址**
- 也就是 `tom` 变量 **引用** 了 **新建的猫对象**
- 使用 `print` 输出 **对象变量**，默认情况下，是能够输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 **在内存中的地址**（**十六进制表示**）

> 提示：在计算机中，通常使用 十六进制 表示 内存地址
> 
> - **十进制** 和 **十六进制** 都是用来表达数字的，只是表示的方式不一样
> - **十进制** 和 **十六进制** 的数字之间可以来回转换
- `%d` 可以以 **10 进制** 输出数字
- `%x` 可以以 **16 进制** 输出数字

### 案例进阶 —— 使用 Cat 类再创建一个对象

```python
lazy_cat = Cat()
lazy_cat.eat()
lazy_cat.drink()

```

> 提问：tom 和 lazy_cat 是同一个对象吗？
> 

## 3. 方法中的 `self` 参数

### 3.1 案例改造 —— 给对象增加属性

- 在 `Python` 中，要 **给对象设置属性**，非常的容易，**但是不推荐使用**
- 因为：对象属性的封装应该封装在类的内部
- 只需要在 **类的外部的代码** 中直接通过 `.` 设置一个属性即可

> 注意：这种方式虽然简单，但是不推荐使用！
> 

```python
tom.name = "Tom"
...

lazy_cat.name = "大懒猫"

```

### 3.2 使用 `self` 在方法内部输出每一只猫的名字

> 由 哪一个对象 调用的方法，方法内的 self 就是 哪一个对象的引用
> 
- 在类封装的方法内部，`self` 就表示 **当前调用方法的对象自己**
- **调用方法时**，程序员不需要传递 `self` 参数
- **在方法内部**
- 可以通过 `self.` **访问对象的属性**
- 也可以通过 `self.` **调用其他的对象方法**
- 改造代码如下：

```python
class Cat:

def eat(self):
print("%s 爱吃鱼" % self.name)

tom = Cat()
tom.name = "Tom"
tom.eat()

lazy_cat = Cat()
lazy_cat.name = "大懒猫"
lazy_cat.eat()

```

- 在 **类的外部**，通过 `变量名.` 访问对象的 **属性和方法**
- 在 **类封装的方法中**，通过 `self.` 访问对象的 **属性和方法**

## 4. 初始化方法

### 4.1 之前代码存在的问题 —— 在类的外部给对象增加属性

- 将案例代码进行调整，**先调用方法 再设置属性**，观察一下执行效果

```python
tom = Cat()
tom.drink()
tom.eat()
tom.name = "Tom"
print(tom)

```

- 程序执行报错如下：

```
AttributeError: 'Cat' object has no attribute 'name'
属性错误：'Cat' 对象没有 'name' 属性

```

**提示**

- 在日常开发中，不推荐在 **类的外部** 给对象增加属性
- 如果**在运行时，没有找到属性，程序会报错**
- 对象应该包含有哪些属性，应该 **封装在类的内部**

### 4.2 初始化方法

- 当使用 `类名()` 创建对象时，会 **自动** 执行以下操作：
1. 为对象在内存中 **分配空间** —— 创建对象
2. 为对象的属性 **设置初始值** —— 初始化方法(`init`)
- 这个 **初始化方法** 就是 `__init__` 方法，`__init__` 是对象的**内置方法**

> __init__ 方法是 专门 用来定义一个类 具有哪些属性的方法！
> 

在 `Cat` 中增加 `__init__` 方法，验证该方法在创建对象时会被自动调用

```python
class Cat:
"""这是一个猫类"""

def __init__(self):
print("初始化方法")

```

### 4.3 在初始化方法内部定义属性

- 在 `__init__` 方法内部使用 `self.属性名 = 属性的初始值` 就可以 **定义属性**
- 定义属性之后，再使用 `Cat` 类创建的对象，都会拥有该属性

```python
class Cat:

def __init__(self):

print("这是一个初始化方法")

# 定义用 Cat 类创建的猫对象都有一个 name 的属性
self.name = "Tom"

def eat(self):
print("%s 爱吃鱼" % self.name)

# 使用类名()创建对象的时候，会自动调用初始化方法 __init__
tom = Cat()

tom.eat()

```

### 4.4 改造初始化方法 —— 初始化的同时设置初始值

- 在开发中，如果希望在 **创建对象的同时，就设置对象的属性**，可以对 `__init__` 方法进行 **改造**
1. 把希望设置的属性值，定义成 `__init__` 方法的参数
2. 在方法内部使用 `self.属性 = 形参` 接收外部传递的参数
3. 在创建对象时，使用 `类名(属性1, 属性2...)` 调用

```python
class Cat:

def __init__(self, name):
print("初始化方法 %s" % name)
self.name = name
...

tom = Cat("Tom")
...

lazy_cat = Cat("大懒猫")
...

```

## 5. 内置方法和属性

| 序号 | 方法名    | 类型 | 作用                                         |
| ---- | --------- | ---- | -------------------------------------------- |
| 01   | `__del__` | 方法 | **对象被从内存中销毁**前，会被 **自动** 调用 |
| 02   | `__str__` | 方法 | 返回**对象的描述信息**，`print` 函数输出使用 |

### 5.1 `__del__` 方法（知道）

- 在 `Python` 中
- 当使用 `类名()` 创建对象时，为对象 **分配完空间**后，**自动** 调用 `__init__` 方法
- 当一个 **对象被从内存中销毁** 前，会 **自动** 调用 `__del__` 方法
- **应用场景**
- `__init__` 改造初始化方法，可以让创建对象更加灵活
- `__del__` 如果希望在对象被销毁前，再做一些事情，可以考虑一下 `__del__` 方法
- **生命周期**
- 一个对象从调用 `类名()` 创建，生命周期开始
- 一个对象的 `__del__` 方法一旦被调用，生命周期结束
- 在对象的生命周期内，可以访问对象属性，或者让对象调用方法

```python
class Cat:

def __init__(self, new_name):

self.name = new_name

print("%s 来了" % self.name)

def __del__(self):

print("%s 去了" % self.name)

# tom 是一个全局变量
tom = Cat("Tom")
print(tom.name)

# del 关键字可以删除一个对象
del tom

print("-" * 50)

```

### 5.2 `__str__` 方法

- 在 `Python` 中，使用 `print` 输出 **对象变量**，默认情况下，会输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 **在内存中的地址**（**十六进制表示**）
- 如果在开发中，希望使用 `print` 输出 **对象变量** 时，能够打印 **自定义的内容**，就可以利用 `__str__` 这个内置方法了

> 注意：__str__ 方法必须返回一个字符串
> 

```python
class Cat:

def __init__(self, new_name):

self.name = new_name

print("%s 来了" % self.name)

def __del__(self):

print("%s 去了" % self.name)

def __str__(self):
return "我是小猫：%s" % self.name

tom = Cat("Tom")
print(tom)

```

# 十三、私有属性和私有方法

## 1. 应用场景及定义方式

**应用场景**

- 在实际开发中，**对象** 的 **某些属性或方法** 可能只希望 **在对象的内部被使用**，而 **不希望在外部被访问到**
- **私有属性** 就是 **对象** 不希望公开的 **属性**
- **私有方法** 就是 **对象** 不希望公开的 **方法**

**定义方式**

- 在 **定义属性或方法时**，在 **属性名或者方法名前** 增加 **两个下划线**，定义的就是 **私有** 属性或方法

```python
class Women:

def __init__(self, name):

self.name = name
# 不要问女生的年龄
self.__age = 18

def __secret(self):
print("我的年龄是 %d" % self.__age)

xiaofang = Women("小芳")
# 私有属性，外部不能直接访问
# print(xiaofang.__age)

# 私有方法，外部不能直接调用
# xiaofang.__secret()

```

## 2. 伪私有属性和私有方法（科普）

> 提示：在日常开发中，不要使用这种方式，访问对象的 私有属性 或 私有方法
> 

`Python` 中，并没有 **真正意义** 的 **私有**

- 在给 **属性**、**方法** 命名时，实际是对 **名称** 做了一些特殊处理，使得外界无法访问到
- **处理方式**：在 **名称** 前面加上 `_类名` => `_类名__名称`

```python
# 私有属性，外部不能直接访问到
print(xiaofang._Women__age)

# 私有方法，外部不能直接调用
xiaofang._Women__secret()

```

# 十四、单例

## 目标

- 单例设计模式
- `__new__` 方法
- Python 中的单例

## 1. 单例设计模式

- 设计模式
- **设计模式** 是 **前人工作的总结和提炼**，通常，被人们广泛流传的设计模式都是针对 **某一特定问题** 的成熟的解决方案
- 使用 **设计模式** 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性
- 单例设计模式
- **目的** —— 让 **类** 创建的对象，在系统中 **只有** **唯一的一个实例**
- 每一次执行 `类名()` 返回的对象，**内存地址是相同的**

### 单例设计模式的应用场景

- **音乐播放** 对象
- **回收站** 对象
- **打印机** 对象
- ……

## 2. `__new__` 方法

- 使用 **类名()** 创建对象时，`Python` 的解释器 **首先** 会 调用 `__new__` 方法为对象 **分配空间**
- `__new__` 是一个 由 `object` 基类提供的 **内置的静态方法**，主要作用有两个：
- 在内存中为对象 **分配空间**
- **返回** 对象的引用
- `Python` 的解释器获得对象的 **引用** 后，将引用作为 **第一个参数**，传递给 `__init__` 方法

> 重写 __new__ 方法 的代码非常固定！
> 
- 重写 `__new__` 方法 **一定要** `return super().__new__(cls)`
- 否则 Python 的解释器 **得不到** 分配了空间的 **对象引用**，**就不会调用对象的初始化方法**
- 注意：`__new__` 是一个静态方法，在调用时需要 **主动传递** `cls` 参数

**示例代码**

```python
class MusicPlayer(object):

def __new__(cls, *args, **kwargs):
# 如果不返回任何结果，
return super().__new__(cls)

def __init__(self):
print("初始化音乐播放对象")

player = MusicPlayer()

print(player)

```

## 3. Python 中的单例

- **单例** —— 让 **类** 创建的对象，在系统中 **只有** **唯一的一个实例**
1. 定义一个 **类属性**，初始值是 `None`，用于记录 **单例对象的引用**
2. 重写 `__new__` 方法
3. 如果 **类属性** `is None`，调用父类方法分配空间，并在类属性中记录结果
4. 返回 **类属性** 中记录的 **对象引用**

```python
class MusicPlayer(object):

# 定义类属性记录单例对象引用
instance = None

def __new__(cls, *args, **kwargs):

# 1. 判断类属性是否已经被赋值
if cls.instance is None:
cls.instance = super().__new__(cls)

# 2. 返回类属性的单例引用
return cls.instance

```

### 只执行一次初始化工作

- 在每次使用 `类名()` 创建对象时，`Python` 的解释器都会自动调用两个方法：
- `__new__` 分配空间
- `__init__` 对象初始化
- 在上一小节对 `__new__` 方法改造之后，每次都会得到 **第一次被创建对象的引用**
- 但是：**初始化方法还会被再次调用**

**需求**

- 让 **初始化动作** 只被 **执行一次**

**解决办法**

1. 定义一个类属性 `init_flag` 标记是否 **执行过初始化动作**，初始值为 `False`
2. 在 `__init__` 方法中，判断 `init_flag`，如果为 `False` 就执行初始化动作
3. 然后将 `init_flag` 设置为 `True`
4. 这样，再次 **自动** 调用 `__init__` 方法时，**初始化动作就不会被再次执行** 了

```python
class MusicPlayer(object):

# 记录第一个被创建对象的引用
instance = None
# 记录是否执行过初始化动作
init_flag = False

def __new__(cls, *args, **kwargs):

# 1. 判断类属性是否是空对象
if cls.instance is None:
# 2. 调用父类的方法，为第一个对象分配空间
cls.instance = super().__new__(cls)

# 3. 返回类属性保存的对象引用
return cls.instance

def __init__(self):

if not MusicPlayer.init_flag:
print("初始化音乐播放器")

MusicPlayer.init_flag = True

# 创建多个对象
player1 = MusicPlayer()
print(player1)

player2 = MusicPlayer()
print(player2)

```

# 十五、多态

## 目标

- 多态

**面向对象三大特性**

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中
- 定义类的准则
2. **继承** **实现代码的重用**，相同的代码不需要重复的编写
- 设计类的技巧
- 子类针对自己特有的需求，编写特定的代码
3. **多态** 不同的 **子类对象** 调用相同的 **父类方法**，产生不同的执行结果
- **多态** 可以 **增加代码的灵活度**
- 以 **继承** 和 **重写父类方法** 为前提
- 是调用方法的技巧，**不会影响到类的内部设计**

## 多态案例演练

**需求**

4. 在 `Dog` 类中封装方法 `game`
- 普通狗只是简单的玩耍
5. 定义 `XiaoTianDog` 继承自 `Dog`，并且重写 `game` 方法
- 哮天犬需要在天上玩耍
6. 定义 `Person` 类，并且封装一个 **和狗玩** 的方法
- 在方法内部，直接让 **狗对象** 调用 `game` 方法

**案例小结**

- `Person` 类中只需要让 **狗对象** 调用 `game` 方法，而不关心具体是 **什么狗**
- `game` 方法是在 `Dog` 父类中定义的
- 在程序执行时，传入不同的 **狗对象** 实参，就会产生不同的执行效果

> 多态 更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！
> 

```python
class Dog(object):

def __init__(self, name):
self.name = name

def game(self):
print("%s 蹦蹦跳跳的玩耍..." % self.name)

class XiaoTianDog(Dog):

def game(self):
print("%s 飞到天上去玩耍..." % self.name)

class Person(object):

def __init__(self, name):
self.name = name

def game_with_dog(self, dog):

print("%s 和 %s 快乐的玩耍..." % (self.name, dog.name))

# 让狗玩耍
dog.game()

# 1. 创建一个狗对象
# wangcai = Dog("旺财")
wangcai = XiaoTianDog("飞天旺财")

# 2. 创建一个小明对象
xiaoming = Person("小明")

# 3. 让小明调用和狗玩的方法
xiaoming.game_with_dog(wangcai)

```

# 十六、继承

## 目标

- 单继承
- 多继承

**面向对象三大特性**

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中
2. **继承** **实现代码的重用**，相同的代码不需要重复的编写
3. **多态** 不同的对象调用相同的方法，产生不同的执行结果，**增加代码的灵活度**

## 1. 单继承

### 1.1 继承的概念、语法和特点

**继承的概念**：**子类** 拥有 **父类** 的所有 **方法** 和 **属性**

### 1) 继承的语法

```python
class 类名(父类名):

pass

```

- **子类** 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发
- **子类** 中应该根据 **职责**，封装 **子类特有的** **属性和方法**

### 2) 专业术语

- `Dog` 类是 `Animal` 类的**子类**，`Animal` 类是 `Dog` 类的**父类**，`Dog` 类从 `Animal` 类**继承**
- `Dog` 类是 `Animal` 类的**派生类**，`Animal` 类是 `Dog` 类的**基类**，`Dog` 类从 `Animal` 类**派生**

### 3) 继承的传递性

- `C` 类从 `B` 类继承，`B` 类又从 `A` 类继承
- 那么 `C` 类就具有 `B` 类和 `A` 类的所有属性和方法

**子类** 拥有 **父类** 以及 **父类的父类** 中封装的所有 **属性** 和 **方法**

**提问**

**哮天犬** 能够调用 `Cat` 类中定义的 `catch` 方法吗？

**答案**

**不能**，因为 **哮天犬** 和 `Cat` 之间没有 **继承** 关系

### 1.2 方法的重写

- **子类** 拥有 **父类** 的所有 **方法** 和 **属性**
- **子类** 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发

**应用场景**

- 当 **父类** 的方法实现不能满足子类需求时，可以对方法进行 **重写(override)**

**重写** 父类方法有两种情况：

1. **覆盖** 父类的方法
2. 对父类方法进行 **扩展**

### 1) 覆盖父类的方法

- 如果在开发中，**父类的方法实现** 和 **子类的方法实现**，**完全不同**
- 就可以使用 **覆盖** 的方式，**在子类中** **重新编写** 父类的方法实现

> 具体的实现方式，就相当于在 子类中 定义了一个 和父类同名的方法并且实现
> 

重写之后，在运行时，**只会调用** 子类中重写的方法，而不再会调用 **父类封装的方法**

### 2) 对父类方法进行 **扩展**

- 如果在开发中，**子类的方法实现** 中 **包含** **父类的方法实现**
- **父类原本封装的方法实现** 是 **子类方法的一部分**
- 就可以使用 **扩展** 的方式
1. **在子类中** **重写** 父类的方法
2. 在需要的位置使用 `super().父类方法` 来调用父类方法的执行
3. 代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

### 关于 `super`

- 在 `Python` 中 `super` 是一个 **特殊的类**
- `super()` 就是使用 `super` 类创建出来的对象
- **最常** 使用的场景就是在 **重写父类方法时**，调用 **在父类中封装的方法实现**

### 调用父类方法的另外一种方式（知道）

> 在 Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式：
> 

```python
父类名.方法(self)

```

- 这种方式，目前在 `Python 3.x` 还支持这种方式
- 这种方法 **不推荐使用**，因为一旦 **父类发生变化**，方法调用位置的 **类名** 同样需要修改

**提示**

- 在开发时，`父类名` 和 `super()` 两种方式不要混用
- 如果使用 **当前子类名** 调用方法，会形成递归调用，**出现死循环**

### 1.3 父类的 私有属性 和 私有方法

1. **子类对象** **不能** 在自己的方法内部，**直接** 访问 父类的 **私有属性** 或 **私有方法**
2. **子类对象** 可以通过 **父类** 的 **公有方法** **间接** 访问到 **私有属性** 或 **私有方法**

> 私有属性、方法 是对象的隐私，不对外公开，外界 以及 子类 都不能直接访问私有属性、方法 通常用于做一些内部的事情
> 

**示例**

- `B` 的对象不能直接访问 `__num2` 属性
- `B` 的对象不能在 `demo` 方法内访问 `__num2` 属性
- `B` 的对象可以在 `demo` 方法内，调用父类的 `test` 方法
- 父类的 `test` 方法内部，能够访问 `__num2` 属性和 `__test` 方法

## 2. 多继承

**概念**

- **子类** 可以拥有 **多个父类**，并且具有 **所有父类** 的 **属性** 和 **方法**
- 例如：**孩子** 会继承自己 **父亲** 和 **母亲** 的 **特性**

**语法**

```python
class 子类名(父类名1, 父类名2...)
pass

```

### 2.1 多继承的使用注意事项

**问题的提出**

- 如果 **不同的父类** 中存在 **同名的方法**，**子类对象** 在调用方法时，会调用 **哪一个父类中**的方法呢？

> 提示：开发时，应该尽量避免这种容易产生混淆的情况！ —— 如果 父类之间 存在 同名的属性或者方法，应该 尽量避免 使用多继承
> 

### Python 中的 MRO —— 方法搜索顺序（知道）

- `Python` 中针对 **类** 提供了一个 **内置属性** `__mro__` 可以查看 **方法** 搜索顺序
- MRO 是 `method resolution order`，主要用于 **在多继承时判断 方法、属性 的调用 路径**

```python
print(C.__mro__)

```

**输出结果**

```
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)

```

- 在搜索方法时，是按照 `__mro__` 的输出结果 **从左至右** 的顺序查找的
- 如果在当前类中 **找到方法，就直接执行，不再搜索**
- 如果 **没有找到，就查找下一个类** 中是否有对应的方法，**如果找到，就直接执行，不再搜索**
- 如果找到最后一个类，还没有找到方法，程序报错

### 2.2 新式类与旧式（经典）类

> object 是 Python 为所有对象提供的 基类，提供有一些内置的属性和方法，可以使用 dir 函数查看
> 
- **新式类**：以 `object` 为基类的类，**推荐使用**
- **经典类**：不以 `object` 为基类的类，**不推荐使用**
- 在 `Python 3.x` 中定义类时，如果没有指定父类，会 **默认使用** `object` 作为该类的 **基类** —— `Python 3.x` 中定义的类都是 **新式类**
- 在 `Python 2.x` 中定义类时，如果没有指定父类，则不会以 `object` 作为 **基类**

> 新式类 和 经典类 在多继承时 —— 会影响到方法的搜索顺序
> 

为了保证编写的代码能够同时在 `Python 2.x` 和 `Python 3.x` 运行！
今后在定义类时，**如果没有父类，建议统一继承自 `object`**

```python
class 类名(object):
pass

```

# 十七、类属性和类方法

## 目标

- 类的结构
- 类属性和实例属性
- 类方法和静态方法

## 1. 类的结构

### 1.1 术语 —— 实例

1. 使用面相对象开发，**第 1 步** 是设计 **类**
2. 使用 **类名()** 创建对象，**创建对象** 的动作有两步：
- 在内存中为对象 **分配空间**
- 调用初始化方法 `__init__` 为 **对象初始化**
3. 对象创建后，**内存** 中就有了一个对象的 **实实在在** 的存在 —— **实例**

因此，通常也会把：

4. 创建出来的 **对象** 叫做 **类** 的 **实例**
5. 创建对象的 **动作** 叫做 **实例化**
6. **对象的属性** 叫做 **实例属性**
7. **对象调用的方法** 叫做 **实例方法**

在程序执行时：

8. 对象各自拥有自己的 **实例属性**
9. 调用对象方法，可以通过 `self.`
- 访问自己的属性
- 调用自己的方法

**结论**

- **每一个对象** 都有自己 **独立的内存空间**，**保存各自不同的属性**
- **多个对象的方法**，**在内存中只有一份**，在调用方法时，**需要把对象的引用** 传递到方法内部

### 1.2 类是一个特殊的对象

> Python 中 一切皆对象：
> 
> - `class AAA:` 定义的类属于 **类对象**
> - `obj1 = AAA()` 属于 **实例对象**
- 在程序运行时，**类** 同样 **会被加载到内存**
- 在 `Python` 中，**类** 是一个特殊的对象 —— **类对象**
- 在程序运行时，**类对象** 在内存中 **只有一份**，使用 **一个类** 可以创建出 **很多个对象实例**
- 除了封装 **实例** 的 **属性** 和 **方法**外，**类对象** 还可以拥有自己的 **属性** 和 **方法**
1. **类属性**
2. **类方法**
- 通过 **类名.** 的方式可以 **访问类的属性** 或者 **调用类的方法**

## 2. 类属性和实例属性

### 2.1 概念和使用

- **类属性** 就是给 **类对象** 中定义的 **属性**
- 通常用来记录 **与这个类相关** 的特征
- **类属性** **不会用于**记录 **具体对象的特征**

**示例需求**

- 定义一个 **工具类**
- 每件工具都有自己的 `name`
- **需求** —— 知道使用这个类，创建了多少个工具对象？

```python
class Tool(object):

# 使用赋值语句，定义类属性，记录创建工具对象的总数
count = 0

def __init__(self, name):
self.name = name

# 针对类属性做一个计数+1
Tool.count += 1

# 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")
tool3 = Tool("铁锹")

# 知道使用 Tool 类到底创建了多少个对象?
print("现在创建了 %d 个工具" % Tool.count)

```

### 2.2 属性的获取机制（科普）

- 在 `Python` 中 **属性的获取** 存在一个 **向上查找机制**
- 因此，要访问类属性有两种方式：
1. **类名.类属性**
2. **对象.类属性** （不推荐）

**注意**

- 如果使用 `对象.类属性 = 值` 赋值语句，只会 **给对象添加一个属性**，而不会影响到 **类属性的值**

## 3. 类方法和静态方法

### 3.1 类方法

- **类属性** 就是针对 **类对象** 定义的属性
- 使用 **赋值语句** 在 `class` 关键字下方可以定义 **类属性**
- **类属性** 用于记录 **与这个类相关** 的特征
- **类方法** 就是针对 **类对象** 定义的方法
- 在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的 **类方法**

**语法如下**

```python
@classmethod
def 类方法名(cls):
pass

```

- 类方法需要用 **修饰器** `@classmethod` 来标识，**告诉解释器这是一个类方法**
- 类方法的 **第一个参数** 应该是 `cls`
- 由 **哪一个类** 调用的方法，方法内的 `cls` 就是 **哪一个类的引用**
- 这个参数和 **实例方法** 的第一个参数是 `self` 类似
- **提示** 使用其他名称也可以，不过习惯使用 `cls`
1. 通过 **类名.** 调用 **类方法**，**调用方法时**，不需要传递 `cls` 参数
2. **在方法内部**
- 可以通过 `cls.` **访问类的属性**
- 也可以通过 `cls.` **调用其他的类方法**

**示例需求**

- 定义一个 **工具类**
- 每件工具都有自己的 `name`
- **需求** —— 在 **类** 封装一个 `show_tool_count` 的类方法，输出使用当前这个类，创建的对象个数

```python
@classmethod
def show_tool_count(cls):
"""显示工具对象的总数"""
print("工具对象的总数 %d" % cls.count)

```

> 在类方法内部，可以直接使用 cls 访问 类属性 或者 调用类方法
> 

### 3.2 静态方法

- 在开发时，如果需要在 **类** 中封装一个方法，这个方法：
- 既 **不需要** 访问 **实例属性** 或者调用 **实例方法**
- 也 **不需要** 访问 **类属性** 或者调用 **类方法**
- 这个时候，可以把这个方法封装成一个 **静态方法**

**语法如下**

```python
@staticmethod
def 静态方法名():
pass

```

- **静态方法** 需要用 **修饰器** `@staticmethod` 来标识，**告诉解释器这是一个静态方法**
- 通过 **类名.** 调用 **静态方法**

```python
class Dog(object):

# 狗对象计数
dog_count = 0

@staticmethod
def run():

# 不需要访问实例属性也不需要访问类属性的方法
print("狗在跑...")

def __init__(self, name):
self.name = name

```

### 3.3 方法综合案例

**需求**

1. 设计一个 `Game` 类
2. 属性：
- 定义一个 **类属性** `top_score` 记录游戏的 **历史最高分**
- 定义一个 **实例属性** `player_name` 记录 **当前游戏的玩家姓名**
3. 方法：
- **静态方法** `show_help` 显示游戏帮助信息
- **类方法** `show_top_score` 显示历史最高分
- **实例方法** `start_game` 开始当前玩家的游戏
4. 主程序步骤
- 查看帮助信息
- 查看历史最高分
- 创建游戏对象，开始游戏

### 案例小结

5. **实例方法** —— 方法内部需要访问 **实例属性**
- **实例方法** 内部可以使用 **类名.** 访问类属性
6. **类方法** —— 方法内部 **只** 需要访问 **类属性**
7. **静态方法** —— 方法内部，不需要访问 **实例属性** 和 **类属性**

**提问**

如果方法内部 即需要访问 **实例属性**，又需要访问 **类属性**，应该定义成什么方法？

**答案**

- 应该定义 **实例方法**
- 因为，**类只有一个**，在 **实例方法** 内部可以使用 **类名.** 访问类属性

```python
class Game(object):

# 游戏最高分，类属性
top_score = 0

@staticmethod
def show_help():
print("帮助信息：让僵尸走进房间")

@classmethod
def show_top_score(cls):
print("游戏最高分是 %d" % cls.top_score)

def __init__(self, player_name):
self.player_name = player_name

def start_game(self):
print("[%s] 开始游戏..." % self.player_name)

# 使用类名.修改历史最高分
Game.top_score = 999

# 1. 查看游戏帮助
Game.show_help()

# 2. 查看游戏最高分
Game.show_top_score()

# 3. 创建游戏对象，开始游戏
game = Game("小明")

game.start_game()

# 4. 游戏结束，查看游戏最高分
Game.show_top_score()

```

# 十八、`eval` 函数

`eval()` 函数十分强大 —— **将字符串** 当成 **有效的表达式** 来求值 并 **返回计算结果**

```python
# 基本的数学计算
In [1]: eval("1 + 1")
Out[1]: 2

# 字符串重复
In [2]: eval("'*' * 10")
Out[2]: '**********'

# 将字符串转换成列表
In [3]: type(eval("[1, 2, 3, 4, 5]"))
Out[3]: list

# 将字符串转换成字典
In [4]: type(eval("{'name': 'xiaoming', 'age': 18}"))
Out[4]: dict

```

## 案例 - 计算器

**需求**

1. 提示用户输入一个 **加减乘除混合运算**
2. 返回计算结果

```python
input_str = input("请输入一个算术题：")

print(eval(input_str))

```

## 不要滥用 `eval`

> 在开发时千万不要使用 eval 直接转换 input 的结果
> 

```python
__import__('os').system('ls')

```

- 等价代码

```python
import os

os.system("终端命令")

```

- 执行成功，返回 0
- 执行失败，返回错误信息

# 十九、模块和包

## 目标

- 模块
- 包
- 发布模块

## 1. 模块

### 1.1 模块的概念

> 模块是 Python 程序架构的一个核心概念
> 
- 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
- **模块名** 同样也是一个 **标识符**，需要符合标识符的命名规则
- 在模块中定义的 **全局变量** 、**函数**、**类** 都是提供给外界直接使用的 **工具**
- **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要先 **导入** 这个模块

### 1.2 模块的两种导入方式

### 1）import 导入

```python
import 模块名1, 模块名2

```

> 提示：在导入模块时，每个导入应该独占一行
> 

```python
import 模块名1
import 模块名2

```

- **导入之后**
- 通过 `模块名.` 使用 **模块提供的工具** —— **全局变量**、**函数**、**类**

### 使用 `as` 指定模块的别名

> 如果模块的名字太长，可以使用 as 指定模块的名称，以方便在代码中的使用
> 

```python
import 模块名1 as 模块别名

```

> 注意：模块别名 应该符合 大驼峰命名法
> 

### 2）from...import 导入

- 如果希望 **从某一个模块** 中，导入 **部分** 工具，就可以使用 `from ... import` 的方式
- `import 模块名` 是 **一次性** 把模块中 **所有工具全部导入**，并且通过 **模块名/别名** 访问

```python
# 从 模块 导入 某一个工具
from 模块名1 import 工具名

```

- 导入之后
- **不需要** 通过 `模块名.`
- 可以直接使用 **模块提供的工具** —— **全局变量**、**函数**、**类**

**注意**

> 如果 两个模块，存在 同名的函数，那么 后导入模块的函数，会 覆盖掉先导入的函数
> 
- 开发时 `import` 代码应该统一写在 **代码的顶部**，更容易及时发现冲突
- 一旦发现冲突，可以使用 `as` 关键字 **给其中一个工具起一个别名**

### from...import *（知道）

```python
# 从 模块 导入 所有工具
from 模块名1 import *

```

**注意**

> 这种方式不推荐使用，因为函数重名并没有任何的提示，出现问题不好排查
> 

### 1.3 模块的搜索顺序[扩展]

`Python` 的解释器在 **导入模块** 时，会：

1. 搜索 **当前目录** 指定模块名的文件，**如果有就直接导入**
2. 如果没有，再搜索 **系统目录**

> 在开发时，给文件起名，不要和 系统的模块文件 重名
> 

`Python` 中每一个模块都有一个内置属性 `__file__` 可以 **查看模块** 的 **完整路径**

**示例**

```python
import random

# 生成一个 0～10 的数字
rand = random.randint(0, 10)

print(rand)

```

> 注意：如果当前目录下，存在一个 random.py 的文件，程序就无法正常执行了！
> 
- 这个时候，`Python` 的解释器会 **加载当前目录** 下的 `random.py` 而不会加载 **系统的** `random` 模块

### 1.4 原则 —— 每一个文件都应该是可以被导入的

- 一个 **独立的 `Python` 文件** 就是一个 **模块**
- 在导入文件时，文件中 **所有没有任何缩进的代码** 都会被执行一遍！

**实际开发场景**

- 在实际开发中，每一个模块都是独立开发的，大多都有专人负责
- **开发人员** 通常会在 **模块下方** **增加一些测试代码**
- 仅在模块内使用，而被导入到其他文件中不需要执行

### `__name__` 属性

> __name__ 属性可以做到，测试模块的代码 只在测试情况下被运行，而在 被导入时不会被执行！
> 
- `__name__` 是 `Python` 的一个内置属性，记录着一个 **字符串**
- 如果 **是被其他文件导入的**，`__name__` 就是 **模块名**
- 如果 **是当前执行的程序** `__name__` 是 **`__main__`**

**在很多 `Python` 文件中都会看到以下格式的代码**：

```python
# 导入模块
# 定义全局变量
# 定义类
# 定义函数

# 在代码的最下方
def main():
# ...
pass

# 根据 __name__ 判断是否执行下方代码
if __name__ == "__main__":
main()

```

## 2. 包（Package）

### 概念

- **包** 是一个 **包含多个模块** 的 **特殊目录**
- 目录下有一个 **特殊的文件** `__init__.py`
- 包名的 **命名方式** 和变量名一致，**小写字母** + `_`

**好处**

- 使用 `import 包名` 可以一次性导入 **包** 中 **所有的模块**

### 案例演练

1. 新建一个 `hm_message` 的 **包**
2. 在目录下，新建两个文件 `send_message` 和 `receive_message`
3. 在 `send_message` 文件中定义一个 `send` 函数
4. 在 `receive_message` 文件中定义一个 `receive` 函数
5. 在外部直接导入 `hm_message` 的包

### `__init__.py`

- 要在外界使用 **包** 中的模块，需要在 `__init__.py` 中指定 **对外界提供的模块列表**

```python
# 从 当前目录 导入 模块列表
from . import send_message
from . import receive_message

```

## 3. 发布模块（知道）

- 如果希望自己开发的模块，**分享** 给其他人，可以按照以下步骤操作

### 3.1 制作发布压缩包步骤

### 1) 创建 [setup.py](http://setup.py/)

- `setup.py` 的文件

```python
from distutils.core import setup

setup(name="hm_message",  # 包名
version="1.0",  # 版本
description="itheima's 发送和接收消息模块",  # 描述信息
long_description="完整的发送和接收消息模块",  # 完整描述信息
author="itheima",  # 作者
author_email="itheima@itheima.com",  # 作者邮箱
url="www.itheima.com",  # 主页
py_modules=["hm_message.send_message",
"hm_message.receive_message"])

```

有关字典参数的详细信息，可以参阅官方网站：

[https://docs.python.org/2/distutils/apiref.html](https://docs.python.org/2/distutils/apiref.html)

### 2) 构建模块

```bash
$ python3 setup.py build

```

### 3) 生成发布压缩包

```bash
$ python3 setup.py sdist

```

> 注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！
> 

### 3.2 安装模块

```bash
$ tar -zxvf hm_message-1.0.tar.gz

$ sudo python3 setup.py install

```

**卸载模块**

直接从安装目录下，把安装模块的 **目录** 删除就可以

```python
$ cd /usr/local/lib/python3.5/dist-packages/
$ sudo rm -r hm_message*

```

### 3.3 `pip` 安装第三方模块

- **第三方模块** 通常是指由 **知名的第三方团队** **开发的** 并且被 **程序员广泛使用** 的 `Python` 包 / 模块
- 例如 `pygame` 就是一套非常成熟的 **游戏开发模块**
- `pip` 是一个现代的，通用的 `Python` 包管理工具
- 提供了对 `Python` 包的查找、下载、安装、卸载等功能

安装和卸载命令如下：

```bash
# 将模块安装到 Python 2.x 环境
$ sudo pip install pygame
$ sudo pip uninstall pygame

# 将模块安装到 Python 3.x 环境
$ sudo pip3 install pygame
$ sudo pip3 uninstall pygame

```

### 在 `Mac` 下安装 `iPython`

```bash
$ sudo pip install ipython

```

### 在 `Linux` 下安装 `iPython`

```bash
$ sudo apt install ipython
$ sudo apt install ipython3

```

# 二十、文件

## 目标

- 文件的概念
- 文件的基本操作
- 文件/文件夹的常用操作
- 文本文件的编码方式

## 1. 文件的概念

### 1.1 文件的概念和作用

- 计算机的 **文件**，就是存储在某种 **长期储存设备** 上的一段 **数据**
- 长期存储设备包括：硬盘、U 盘、移动硬盘、光盘...

**文件的作用**

将数据长期保存下来，在需要的时候使用

### 1.2 文件的存储方式

- 在计算机中，文件是以 **二进制** 的方式保存在磁盘上的

### 文本文件和二进制文件

- 文本文件
- 可以使用 **文本编辑软件** 查看
- 本质上还是二进制文件
- 例如：python 的源程序
- 二进制文件
- 保存的内容 不是给人直接阅读的，而是 **提供给其他软件使用的**
- 例如：图片文件、音频文件、视频文件等等
- 二进制文件不能使用 **文本编辑软件** 查看

## 2. 文件的基本操作

### 2.1 操作文件的套路

在 **计算机** 中要操作文件的套路非常固定，一共包含**三个步骤**：

1. 打开文件
2. 读、写文件
- **读** 将文件内容读入内存
- **写** 将内存内容写入文件
3. 关闭文件

### 2.2 操作文件的函数/方法

- 在 `Python` 中要操作文件需要记住 1 个函数和 3 个方法

| 序号 | 函数/方法 | 说明                           |
| ---- | --------- | ------------------------------ |
| 01   | open      | 打开文件，并且返回文件操作对象 |
| 02   | read      | 将文件内容读取到内存           |
| 03   | write     | 将指定内容写入文件             |
| 04   | close     | 关闭文件                       |
- `open` 函数负责打开文件，并且返回文件对象
- `read`/`write`/`close` 三个方法都需要通过 **文件对象** 来调用

### 2.3 read 方法 —— 读取文件

- `open` 函数的第一个参数是要打开的文件名（文件名区分大小写）
- 如果文件 **存在**，返回 **文件操作对象**
- 如果文件 **不存在**，会 **抛出异常**
- `read` 方法可以一次性 **读入** 并 **返回** 文件的 **所有内容**
- `close` 方法负责 **关闭文件**
- 如果 **忘记关闭文件**，**会造成系统资源消耗，而且会影响到后续对文件的访问**
- **注意**：`read` 方法执行后，会把 **文件指针** 移动到 **文件的末尾**

```python
# 1. 打开 - 文件名需要注意大小写
file = open("README")

# 2. 读取
text = file.read()
print(text)

# 3. 关闭
file.close()

```

**提示**

- 在开发中，通常会先编写 **打开** 和 **关闭** 的代码，再编写中间针对文件的 **读/写** 操作！

### 文件指针（知道）

- **文件指针** 标记 **从哪个位置开始读取数据**
- **第一次打开** 文件时，通常 **文件指针会指向文件的开始位置**
- 当执行了 `read` 方法后，**文件指针** 会移动到 **读取内容的末尾**
- 默认情况下会移动到 **文件末尾**

**思考**

- 如果执行了一次 `read` 方法，读取了所有内容，那么再次调用 `read` 方法，还能够获得到内容吗？

**答案**

- 不能
- 第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容

### 2.4 打开文件的方式

- `open` 函数默认以 **只读方式** 打开文件，并且返回文件对象

语法如下：

```python
f = open("文件名", "访问方式")

```

| 访问方式 | 说明                                                                                                     |
| -------- | -------------------------------------------------------------------------------------------------------- |
| r        | 以**只读**方式打开文件。文件的指针将会放在文件的开头，这是**默认模式**。如果文件不存在，抛出异常         |
| w        | 以**只写**方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件                                 |
| a        | 以**追加**方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |
| r+       | 以**读写**方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常                           |
| w+       | 以**读写**方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件                                 |
| a+       | 以**读写**方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |

**提示**

- 频繁的移动文件指针，**会影响文件的读写效率**，开发中更多的时候会以 **只读**、**只写** 的方式来操作文件

**写入文件示例**

```python
# 打开文件
f = open("README", "w")

f.write("hello python！\\n")
f.write("今天天气真好")
f.write("""hello python！
今天天气真好""")
# 关闭文件
f.close()

```

### 2.5 按行读取文件内容

- `read` 方法默认会把文件的 **所有内容** **一次性读取到内存**
- 如果文件太大，对内存的占用会非常严重

### `readline` 方法

- `readline` 方法可以一次读取一行内容
- 方法执行后，会把 **文件指针** 移动到下一行，准备再次读取

**读取大文件的正确姿势**

```python
# 打开文件
file = open("README")

while True:
# 读取一行内容
text = file.readline()

# 判断是否读到内容
if not text:
break

# 每读取一行的末尾已经有了一个 `\\n`
print(text, end="")

# 关闭文件
file.close()

```

### 2.6 文件读写案例 —— 复制文件

**目标**

用代码的方式，来实现文件复制过程

### 小文件复制

- 打开一个已有文件，读取完整内容，并写入到另外一个文件

```python
# 1. 打开文件
file_read = open("README")
file_write = open("README[复件]", "w")

# 2. 读取并写入文件
text = file_read.read()
file_write.write(text)

# 3. 关闭文件
file_read.close()
file_write.close()

```

### 大文件复制

- 打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件

```python
# 1. 打开文件
file_read = open("README")
file_write = open("README[复件]", "w")

# 2. 读取并写入文件
while True:
# 每次读取一行
text = file_read.readline()

# 判断是否读取到内容
if not text:
break

file_write.write(text)

# 3. 关闭文件
file_read.close()
file_write.close()

```

## 3. 文件/目录的常用管理操作

- 在 **终端** / **文件浏览器**、 中可以执行常规的 **文件** / **目录** 管理操作，例如：
- 创建、重命名、删除、改变路径、查看目录内容、……
- 在 `Python` 中，如果希望通过程序实现上述功能，需要导入 `os` 模块

### 文件操作

| 序号 | 方法名 | 说明       | 示例                              |
| ---- | ------ | ---------- | --------------------------------- |
| 01   | rename | 重命名文件 | `os.rename(源文件名, 目标文件名)` |
| 02   | remove | 删除文件   | `os.remove(文件名)`               |

### 目录操作

| 序号 | 方法名     | 说明           | 示例                      |
| ---- | ---------- | -------------- | ------------------------- |
| 01   | listdir    | 目录列表       | `os.listdir(目录名)`      |
| 02   | mkdir      | 创建目录       | `os.mkdir(目录名)`        |
| 03   | rmdir      | 删除目录       | `os.rmdir(目录名)`        |
| 04   | getcwd     | 获取当前目录   | `os.getcwd()`             |
| 05   | chdir      | 修改工作目录   | `os.chdir(目标目录)`      |
| 06   | path.isdir | 判断是否是文件 | `os.path.isdir(文件路径)` |

> 提示：文件或者目录操作都支持 相对路径 和 绝对路径
> 

## 04. 文本文件的编码格式（科普）

- 文本文件存储的内容是基于 **字符编码** 的文件，常见的编码有 `ASCII` 编码，`UNICODE` 编码等

> Python 2.x 默认使用 ASCII 编码格式
Python 3.x 默认使用 UTF-8 编码格式
> 

### 4.1 ASCII 编码和 UNICODE 编码

### `ASCII` 编码

- 计算机中只有 `256` 个 `ASCII` 字符
- 一个 `ASCII` 在内存中占用 **1 个字节** 的空间
- `8` 个 `0/1` 的排列组合方式一共有 `256` 种，也就是 `2 ** 8`

### `UTF-8` 编码格式

- 计算机中使用 **1~6 个字节** 来表示一个 `UTF-8` 字符，涵盖了 **地球上几乎所有地区的文字**
- 大多数汉字会使用 **3 个字节** 表示
- `UTF-8` 是 `UNICODE` 编码的一种编码格式

### 4.2 Ptyhon 2.x 中如何使用中文

> Python 2.x 默认使用 ASCII 编码格式
Python 3.x 默认使用 UTF-8 编码格式
> 
- 在 Python 2.x 文件的 **第一行** 增加以下代码，解释器会以 `utf-8` 编码来处理 python 文件

```python
# *-* coding:utf8 *-*

```

> 这方式是官方推荐使用的！
> 
- 也可以使用

```python
# coding=utf8

```

### unicode 字符串

- 在 `Python 2.x` 中，即使指定了文件使用 `UTF-8` 的编码格式，但是在遍历字符串时，仍然会 **以字节为单位遍历** 字符串
- 要能够 **正确的遍历字符串**，在定义字符串时，需要 **在字符串的引号前**，增加一个小写字母 `u`，告诉解释器这是一个 `unicode` 字符串（使用 `UTF-8` 编码格式的字符串）

```python
# *-* coding:utf8 *-*

# 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串
hello_str = u"你好世界"

print(hello_str)

for c in hello_str:
print(c)

```

# 二十一、异常

## 目标

- 异常的概念
- 捕获异常
- 异常的传递
- 抛出异常

## 1. 异常的概念

- 程序在运行时，如果 `Python 解释器` **遇到** 到一个错误，**会停止程序的执行，并且提示一些错误信息**，这就是 **异常**
- **程序停止执行并且提示错误信息** 这个动作，我们通常称之为：**抛出(raise)异常**

> 程序开发时，很难将 所有的特殊情况 都处理的面面俱到，通过 异常捕获 可以针对突发事件做集中的处理，从而保证程序的 稳定性和健壮性
> 

## 2. 捕获异常

### 2.1 简单的捕获异常语法

- 在程序开发中，如果 **对某些代码的执行不能确定是否正确**，可以增加 `try(尝试)` 来 **捕获异常**
- 捕获异常最简单的语法格式：

```python
try:
尝试执行的代码
except:
出现错误的处理

```

- `try` **尝试**，下方编写要尝试代码，不确定是否能够正常执行的代码
- `except` **如果不是**，下方编写尝试失败的代码

### 简单异常捕获演练 —— 要求用户输入整数

```python
try:
# 提示用户输入一个数字
num = int(input("请输入数字："))
except:
print("请输入正确的数字")

```

### 2.2 错误类型捕获

- 在程序执行时，可能会遇到 **不同类型的异常**，并且需要 **针对不同类型的异常，做出不同的响应**，这个时候，就需要捕获错误类型了
- 语法如下：

```python
try:
# 尝试执行的代码
pass
except 错误类型1:
# 针对错误类型1，对应的代码处理
pass
except (错误类型2, 错误类型3):
# 针对错误类型2 和 3，对应的代码处理
pass
except Exception as result:
print("未知错误 %s" % result)

```

- 当 `Python` 解释器 **抛出异常** 时，**最后一行错误信息的第一个单词，就是错误类型**

### 异常类型捕获演练 —— 要求用户输入整数

**需求**

1. 提示用户输入一个整数
2. 使用 `8` 除以用户输入的整数并且输出

```python
try:
num = int(input("请输入整数："))
result = 8 / num
print(result)
except ValueError:
print("请输入正确的整数")
except ZeroDivisionError:
print("除 0 错误")

```

### 捕获未知错误

- 在开发时，**要预判到所有可能出现的错误**，还是有一定难度的
- 如果希望程序 **无论出现任何错误**，都不会因为 `Python` 解释器 **抛出异常而被终止**，可以再增加一个 `except`

语法如下：

```python
except Exception as result:
print("未知错误 %s" % result)

```

### 2.3 异常捕获完整语法

- 在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下：

> 提示：
> 
> - 有关完整语法的应用场景，在后续学习中，**结合实际的案例**会更好理解
> - 现在先对这个语法结构有个印象即可

```python
try:
# 尝试执行的代码
pass
except 错误类型1:
# 针对错误类型1，对应的代码处理
pass
except 错误类型2:
# 针对错误类型2，对应的代码处理
pass
except (错误类型3, 错误类型4):
# 针对错误类型3 和 4，对应的代码处理
pass
except Exception as result:
# 打印错误信息
print(result)
else:
# 没有异常才会执行的代码
pass
finally:
# 无论是否有异常，都会执行的代码
print("无论是否有异常，都会执行的代码")

```

- `else` 只有在没有异常时才会执行的代码
- `finally` 无论是否有异常，都会执行的代码
- 之前一个演练的 **完整捕获异常** 的代码如下：

```python
try:
num = int(input("请输入整数："))
result = 8 / num
print(result)
except ValueError:
print("请输入正确的整数")
except ZeroDivisionError:
print("除 0 错误")
except Exception as result:
print("未知错误 %s" % result)
else:
print("正常执行")
finally:
print("执行完成，但是不保证正确")

```

## 3. 异常的传递

- **异常的传递** —— 当 **函数/方法** 执行 **出现异常**，会 **将异常传递** 给 函数/方法 的 **调用一方**
- 如果 **传递到主程序**，仍然 **没有异常处理**，程序才会被终止

> 提示
> 
- 在开发中，可以在主函数中增加 **异常捕获**
- 而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 **异常捕获** 中
- 这样就不需要在代码中，增加大量的 **异常捕获**，能够保证代码的整洁

**需求**

1. 定义函数 `demo1()` **提示用户输入一个整数并且返回**
2. 定义函数 `demo2()` 调用 `demo1()`
3. 在主程序中调用 `demo2()`

```python
def demo1():
return int(input("请输入一个整数："))

def demo2():
return demo1()

try:
print(demo2())
except ValueError:
print("请输入正确的整数")
except Exception as result:
print("未知错误 %s" % result)

```

## 04. 抛出 `raise` 异常

### 4.1 应用场景

- 在开发中，除了 **代码执行出错** `Python` 解释器会 **抛出** 异常之外
- 还可以根据 **应用程序** **特有的业务需求** **主动抛出异常**

**示例**

- 提示用户 **输入密码**，如果 **长度少于 8**，抛出 **异常**

**注意**

- 当前函数 **只负责** 提示用户输入密码，如果 **密码长度不正确，需要其他的函数进行额外处理**
- 因此可以 **抛出异常**，由其他需要处理的函数 **捕获异常**

### 4.2 抛出异常

- `Python` 中提供了一个 `Exception` **异常类**
- 在开发时，如果满足 **特定业务需求时**，希望 **抛出异常**，可以：
1. **创建** 一个 `Exception` 的 **对象**
2. 使用 `raise` **关键字** 抛出 **异常对象**

**需求**

- 定义 `input_password` 函数，提示用户输入密码
- 如果用户输入长度 < 8，抛出异常
- 如果用户输入长度 >=8，返回输入的密码

```python
def input_password():

# 1. 提示用户输入密码
pwd = input("请输入密码：")

# 2. 判断密码长度，如果长度 >= 8，返回用户输入的密码
if len(pwd) >= 8:
return pwd

# 3. 密码长度不够，需要抛出异常
# 1> 创建异常对象 - 使用异常的错误信息字符串作为参数
ex = Exception("密码长度不够")

# 2> 抛出异常对象
raise ex

try:
user_pwd = input_password()
print(user_pwd)
except Exception as result:
print("发现错误：%s" % result)

```