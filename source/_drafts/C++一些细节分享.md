---
title: C++一些细节分享
swiper: false
top: false
toc: true
tocOpen: true
onlyTitle: false
comments: true
share: true
copyright: true
donate: false
mathjax: true
imgTop: true
swiperImg:
swiperDesc:
bgImg:
bgImgTransition:
bgImgDelay:
img: https://cdn.pixabay.com/photo/2023/04/20/12/22/globe-7939725_1280.jpg
excerpt: C++一些细节分享
categories: 计算机
tags: [编程语言, C++]
---

# 一、多态

## 1.什么是多态

多态是指同一函数或方法可以在不同对象上产生不同的行为。它是面向对象编程中的一个重要概念，能够提高代码的灵活性和可扩展性。

- 静态多态是通过函数重载和运算符重载实现的，编译器在编译阶段就能确定函数的地址。
- 动态多态是通过虚函数和基类指针或引用实现的，函数的地址在运行阶段才能确定，能够实现运行时的多态行为。

## 2.多态是如何实现的

多态的实现依赖于继承和虚函数的概念。在C++中，通过在基类中声明虚函数，然后在派生类中进行重写，可以实现多态性。当使用基类指针或引用指向派生类对象时，通过调用虚函数，可以根据实际对象的类型来确定调用的函数。这种动态绑定的方式使得程序可以在运行时根据具体对象的类型来决定调用哪个函数，从而实现多态的效果。

## 3.虚函数表

虚函数表是实现动态多态的关键。在每个含有虚函数的类中，编译器会为其生成一个虚函数表（vtable）。虚函数表是一个指针数组，其中存储了该类中所有虚函数的地址。当派生类重写了基类的虚函数时，虚函数表中对应的指针会指向派生类的实现。通过这种方式，编译器在运行时能够根据对象的实际类型找到正确的虚函数地址，从而实现多态的效果。

# 二、空指针、野指针、内存泄漏

## 1.空指针

是指指针变量没有指向任何有效的内存地址，可以用`nullptr`来表示。

## 2.野指针

是指指针变量指向了一个无效的、未初始化的内存地址，它可能指向一个已经释放的内存块或者未被分配的内存。

## 3.内存泄漏

是指在程序运行过程中，动态分配的内存没有被正确释放，导致内存资源的浪费和程序性能的下降。为了避免内存泄漏，我们需要在使用完动态分配的内存后及时使用`delete`或`delete[]`来释放内存。

# 三、const char*和char const*和char *const

`const char*`、`char const*`和`char *const`是C++中用于指向字符常量的指针的不同声明方式。

- `const char*`和`char const*`表示指向常量字符的指针，即指针所指向的字符是不可修改的。这样声明的指针可以用于指向字符串常量。
- `char *const`表示指向字符的指针常量，即指针本身是不可修改的，一旦被初始化，就不能指向其他地址。但是，通过该指针可以修改所指向的字符。

这些声明方式在指针的使用和指向字符常量时具有不同的语义，需要根据具体的需求来选择合适的声明方式。

> Tips: 可以去掉类型，看const修饰的是什么，来判断
> 

# 四、智能指针

智能指针是一种C++的语言特性，用于自动管理动态分配的内存，避免内存泄漏和野指针的问题。与常规的指针不同，智能指针会在适当的时候自动释放内存，无需手动调用`delete`操作。常用的智能指针包括`std::unique_ptr`和`std::shared_ptr`。

- `std::unique_ptr`是一种独占型智能指针，它拥有对对象的唯一所有权。当`std::unique_ptr`超出作用域或被重置时，它会自动调用`delete`释放内存。
- `std::shared_ptr`是一种共享型智能指针，它可以多个指针共享对同一对象的所有权。它使用引用计数来跟踪对象的生命周期，当最后一个`std::shared_ptr`超出作用域时，它会自动释放内存。

使用智能指针可以简化代码，提高内存管理的安全性和可靠性。然而，需要注意循环引用可能导致内存泄漏的问题，可以通过使用`std::weak_ptr`来解决循环引用的情况。

## 1.`std::shared_ptr` 使用方法

`std::shared_ptr`是一种智能指针，它可以多个指针共享对同一对象的所有权。为了使用`std::shared_ptr`，首先需要包含头文件`<memory>`。然后，可以使用`std::make_shared`函数来创建一个`std::shared_ptr`对象，它会自动管理对象的生命周期。例如：

```cpp
#include <memory>

int main() {
    std::shared_ptr<int> ptr = std::make_shared<int>(42);

    // 使用ptr指向的对象
    int value = *ptr;

    return 0;
}

```

在上面的示例中，我们创建了一个`std::shared_ptr`指向一个整数对象，并通过解引用操作符`*`来访问对象的值。当`ptr`超出作用域时，`std::shared_ptr`会自动释放对象的内存。

## 2.`std::unique_ptr` 使用方法

`std::unique_ptr`是一种独占型智能指针，它拥有对动态分配的对象的唯一所有权。为了使用`std::unique_ptr`，首先需要包含头文件`<memory>`。然后，可以使用`std::make_unique`函数来创建一个`std::unique_ptr`对象，它会自动管理对象的生命周期。例如：

```cpp
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);

    // 使用ptr指向的对象
    int value = *ptr;

    return 0;
}

```

在上面的示例中，我们创建了一个`std::unique_ptr`指向一个整数对象，并通过解引用操作符`*`来访问对象的值。当`ptr`超出作用域时，`std::unique_ptr`会自动释放对象的内存。

## 3.`std::weak_ptr` 使用方法

`std::weak_ptr`是一种智能指针，用于解决`std::shared_ptr`可能导致的循环引用和内存泄漏问题。`std::weak_ptr`可以指向`std::shared_ptr`所管理的对象，但不会增加对象的引用计数。为了使用`std::weak_ptr`，首先需要包含头文件`<memory>`。然后，可以使用`std::weak_ptr`来创建一个`std::weak_ptr`对象，例如：

```cpp
#include <memory>

int main() {
    std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);
    std::weak_ptr<int> weakPtr = sharedPtr;

    // 使用weakPtr指向的对象
    if (auto lockedPtr = weakPtr.lock()) {
        int value = *lockedPtr;
    }

    return 0;
}

```

在上面的示例中，我们创建了一个`std::shared_ptr`指向一个整数对象，并通过`std::weak_ptr`来创建一个`std::weak_ptr`对象。通过调用`lock()`函数，可以获取一个`std::shared_ptr`指向的对象的强引用。这个强引用可以被使用，只要对象还存在。当对象被释放后，`lock()`函数将返回一个空指针。

使用`std::weak_ptr`可以避免循环引用导致的内存泄漏问题，同时仍然可以访问所管理的对象。这对于需要跟踪对象生命周期的场景非常有用。

## 4.`std::shared_ptr` 如何使用引用计数的方式来实现自动释放内存的

当创建一个`std::shared_ptr`指向一个对象时，会将对象的引用计数初始化为1。每当有一个新的`std::shared_ptr`指向该对象时，引用计数就会增加1。当引用计数减少到0时，即没有任何`std::shared_ptr`指向该对象时，会自动调用`delete`释放对象的内存。这种引用计数的方式确保了对象在不再被使用时能够被正确释放，避免了内存泄漏的问题。

> Tips: 使用std::shared_ptr时需要避免循环引用，因为循环引用会导致对象的引用计数永远不会减少到0，从而导致内存泄漏。可以使用std::weak_ptr来打破循环引用。
> 

## 5.什么是循环引用

循环引用是指两个或多个对象相互引用，形成一个环形的引用关系。这种情况通常会导致内存泄漏和程序崩溃。

例如，假设有两个类 A 和 B，它们之间相互引用：

```cpp
class A {
public:
    B* b_;
    A(B* b) : b_(b) {}
};

class B {
public:
    A* a_;
    B(A* a) : a_(a) {}
};
```

如果在创建 A 和 B 的对象时，不小心将它们相互关联，就会形成循环引用：

```cpp
A* a = new A(new B(new A(new B(a))));
B* b = new B(new A(new B(b)));
```

在这种情况下，A 和 B 的对象都不能被销毁，因为它们相互引用，导致它们的引用计数永远不为零。这就导致了内存泄漏。另外，由于循环引用可能导致程序的运行时状态不稳定，可能会导致程序崩溃或出现错误。

# 五、死锁

## 1.什么是死锁

当两个或多个进程在执行过程中，因争夺资源而造成的一种相互等待的现象，使得每个进程都无法继续执行下去，称作死锁。

死锁的发生必须具备以下四个条件：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

## 2.怎么避免死锁

1. 预先排序：在进行资源分配时，按照一定的顺序来分配资源，这样可以避免循环等待的情况。
2. 限制并发：限制同时访问同一资源的进程数量，以降低死锁的风险。
3. 使用事务：在数据库系统中，使用事务可以确保在事务结束前，所有的资源都被释放，从而避免死锁。
4. 使用乐观并发控制：乐观并发控制是一种基于检测和恢复的并发控制方法，它通过在执行过程中不断检测是否存在冲突，并在发现冲突时进行恢复，从而避免死锁。
5. 使用悲观并发控制：悲观并发控制是一种基于锁的并发控制方法，它通过在访问共享资源前获取锁来避免死锁。但是，这种方法容易导致锁的竞争和性能下降，因此需要谨慎使用。

# 六、虚拟内存

# 七、extern

# 八、变量的存储类型
